# distutils: language = c++
# distutils: include_dirs = dwave/gate/simulator/
# cython: language_level=3
# THIS FILE WAS AUTOMATICALLY GENERATED BY dwave/gate/simulator/operation_generation.py

cimport numpy as np
from libc.stdint cimport uint64_t

cdef extern from "./ops.h" nogil:
    void c_single_qubit_little_endian "single_qubit_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_single_qubit_big_endian "single_qubit_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_gate_control_little_endian "apply_gate_control_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0
    )

    void c_apply_gate_control_big_endian "apply_gate_control_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0
    )

    void c_apply_gate_two_control_little_endian "apply_gate_two_control_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0, uint64_t control1
    )

    void c_apply_gate_two_control_big_endian "apply_gate_two_control_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t control0, uint64_t control1
    )

    void c_apply_swap_little_endian "apply_swap_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1
    )

    void c_apply_swap_big_endian "apply_swap_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1
    )

    void c_apply_cswap_little_endian "apply_cswap_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1, uint64_t control0
    )

    void c_apply_cswap_big_endian "apply_cswap_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0, uint64_t target1, uint64_t control0
    )

    void c_apply_dephase_0_little_endian "apply_dephase_0_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_dephase_0_big_endian "apply_dephase_0_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_dephase_1_little_endian "apply_dephase_1_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_dephase_1_big_endian "apply_dephase_1_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_amp_damp_0_little_endian "apply_amp_damp_0_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_amp_damp_0_big_endian "apply_amp_damp_0_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_amp_damp_1_little_endian "apply_amp_damp_1_little_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )

    void c_apply_amp_damp_1_big_endian "apply_amp_damp_1_big_endian" (
        uint64_t num_qubits,
        np.complex128_t* state_vector,
        np.complex128_t* gate_matrix,
        uint64_t target0
    )


cdef inline single_qubit(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0,
    little_endian=True,
):
    if little_endian:
        c_single_qubit_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )
    else:
        c_single_qubit_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )

cdef inline apply_gate_control(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t control0,
    little_endian=True,
):
    if little_endian:
        c_apply_gate_control_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0
        )
    else:
        c_apply_gate_control_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0
        )

cdef inline apply_gate_two_control(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t control0, uint64_t control1,
    little_endian=True,
):
    if little_endian:
        c_apply_gate_two_control_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0, control1
        )
    else:
        c_apply_gate_two_control_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, control0, control1
        )

cdef inline apply_swap(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t target1,
    little_endian=True,
):
    if little_endian:
        c_apply_swap_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1
        )
    else:
        c_apply_swap_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1
        )

cdef inline apply_cswap(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0, uint64_t target1, uint64_t control0,
    little_endian=True,
):
    if little_endian:
        c_apply_cswap_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1, control0
        )
    else:
        c_apply_cswap_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0, target1, control0
        )

cdef inline apply_dephase_0(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0,
    little_endian=True,
):
    if little_endian:
        c_apply_dephase_0_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )
    else:
        c_apply_dephase_0_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )

cdef inline apply_dephase_1(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0,
    little_endian=True,
):
    if little_endian:
        c_apply_dephase_1_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )
    else:
        c_apply_dephase_1_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )

cdef inline apply_amp_damp_0(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0,
    little_endian=True,
):
    if little_endian:
        c_apply_amp_damp_0_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )
    else:
        c_apply_amp_damp_0_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )

cdef inline apply_amp_damp_1(
    uint64_t num_qubits,
    complex[::1] state_vector,
    complex[:,:] gate_matrix,
    uint64_t target0,
    little_endian=True,
):
    if little_endian:
        c_apply_amp_damp_1_little_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )
    else:
        c_apply_amp_damp_1_big_endian(
            num_qubits,
            <np.complex128_t*>&state_vector[0],
            <np.complex128_t*>&gate_matrix[0, 0],
            target0
        )

