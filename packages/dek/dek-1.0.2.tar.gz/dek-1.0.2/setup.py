# -*- coding: utf-8 -*-
from setuptools import setup

modules = \
['dek']
install_requires = \
['xmod>=1.3.2,<2.0.0']

setup_kwargs = {
    'name': 'dek',
    'version': '1.0.2',
    'description': 'ðŸŽ´ dek: the decorator-decorator ðŸŽ´',
    'long_description': 'ðŸ—ƒ dek - the decorator-decorator ðŸ—ƒ\n======================================================\n\n``dek`` decorates your decorators to diminish defects and drudgery.\n\nWriting a Python decorator which takes no parameters isn\'t hard.\n\nBut writing a decorator with parameters is less easy - and more work\nif you want to decorate classes, like ``unittest.mock.patch`` does.\n\n``dek`` is a decorator for decorators that does this deftly with a\nsingle tiny function.\n\nEXAMPLE\n---------\n\nWrite a decorator ``before`` that prints a function\'s arguments with a\nlabel before it executes.\n\nWith ``dek``, it\'s a few lines:\n\n.. code-block:: python\n\n    import dek\n\n    @dek\n    def before(pfunc, label=\'hey:\'):\n        print(label, pfunc.func.__name__)\n        return pfunc()\n\n    # Done! To use your new decorator:\n\n    @before\n    def phone(two, four=4):\n        print(\'Calling\', two + two, four * four)\n\n    one(32, four=3)\n\n    # That prints something like:\n    #\n    # hey: functools.partial(<function phone at 0x7fafa8072b00>, 32, four=3)\n    # Calling 64 9\n\n``pfunc`` is a ``functools.partial`` that represents the call the decorator\ndecorator intercepted.\n\nWithout ``dek`` it\'s actual work:\n\n.. code-block:: python\n\n    import functools\n\n    def before(func=None, label=\'label\'):\n        if func:\n            @functools.wraps(func)\n            def wrapped(*args, **kwargs):\n                print(label, args, kwargs)\n                return func(*args, **kwargs)\n\n            return wrapped\n\n        return functools.partial(before, label=label)\n\n\nFor finer control over function signatures there is deferred mode:\n\n.. code-block:: python\n\n    @dek(defer=True)\n    def before(func, label=\'debug\'):\n        def wrapped(foo, bar):\n            print(label, foo, bar)\n            return func(foo, bar)\n\n        return wrapped\n\nAnd there\'s a ``methods`` setting that lets your decorator work well\non classes, much like ``unittest.mock.patch`` does.\n\n.. code-block:: python\n\n    import dek\n\n    @dek(methods=\'test\')\n    def before(pfunc):\n        print(\'HERE\', *pfunc.args)\n        return pfunc()\n\n    @before\n    class Class:\n        def test_one(self):\n            return 1\n\n        def test_two(self):\n            return 2\n\n        def three(self):  # This won\'t get decorated\n            return 1\n\n\n    # Test at the command line:\n    >>> cl = Class()\n    >>> cl.test_one(), cl.test_two(), cl.three()\n    HERE 1\n    HERE 2\n    (1, 2, 3)\n\nNOTES:\n\n`This article <https://medium.com/p/1277a9ed34dc/>`_ talks more about\ndecorators that take parameters and about ``dek`` in general.\n\nFor your advanced decorator problems, the PyPi module\n`decorator <https://github.com/micheles/decorator/blob/master/docs/documentation.md>`_ does not duplicate duties that ``dek`` does, but does\npretty anything else you could conceive of in a decorator library.\n\nAPI\n---\n\n``dek()``\n~~~~~~~~~\n\n.. code-block:: python\n\n  dek(\n       decorator,\n       defer=False,\n       methods=None,\n  )\n\n(`dek.py, 126-267 <https://github.com/rec/dek/blob/master/dek.py#L126-L267>`_)\n\nDecorate a decorator so it works with or without parameters and\ncan decorate all the members of a class.\n\nARGUMENTS\n  decorator\n    The function being decorated\n\n  defer\n    Switch between "simple" and "defer" modes\n\n  methods\n    What to do with class methods when wrapping a class\n\ndek has two modes, simple and deferred.  Simple mode, the default,\nis less work but offers less control.\n\nIn **simple mode** the trivial decorator, the decorator that does nothing,\nis trivial to write:\n\n.. code-block:: python\n\n   @dek\n   def trivial(pfunc):\n       return pfunc()\n\nIn this mode, ``decorator``\'s first argument is ``pfunc``,\na ``functools.partial()`` which bundles the original function called\ntogether with its arguments.\n\nDecorators with parameters aren\'t much harder:\n\n.. code-block:: python\n\n   @dek\n   def before(pfunc, label=\'debug\'):\n       print(label, pfunc)\n       return pfunc()\n\n   @before\n   def do_stuff(a, b=\'default\'):\n      # do stuff\n\n   do_stuff(1)\n   # also prints \'debug do_stuff 1\'\n\n----------------\n\nIn **deferred mode**, ``decorator`` is a function that returns a function\nthat does the work.  This is more code but more flexible.\n\n.. code-block:: python\n\n   @dek(defer=True)\n   def trivial(func):\n       def wrapper(*args, **kwargs):\n           return func(*args, **kwargs)\n\n       return wrapper\n\n   @dek(defer=True)\n   def before(func, label=\'label\'):\n       def wrapper(foo, bar):\n           print(label, foo, bar)\n           return func(foo, bar)\n\n       return wrapper\n\n--------\n\nThe ``methods`` parameter describe how classes are decorated.\n\nIf ``methods`` is ``None`` then classes are decorated like any callable.\n\nIf ``methods`` is _not_ ``None``, then class methods are decorated\ninstead of the class itself:\n\n* If ``methods`` is a string, then only methods whose names start\n  with that string are decorated (which means that if ``methods`` is\n  the empty string, then all methods are decorated).\n\n* If ``methods`` is a callable, then only methods that return true when\n  passed to the callable are decorated.\n\n* If ``methods`` is ``True``, then only public, non-magic methods - methods\n  whose names do *not* start with ``_`` - are decorated.\n\n* If ``methods`` is ``False``, then methods are not decorated (and neither\n  are classes).\n\n(automatically generated by `doks <https://github.com/rec/doks/>`_ on 2022-11-24T17:33:06.304331)\n',
    'author': 'Tom Ritchford',
    'author_email': 'tom@swirly.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'py_modules': modules,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
