# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
C++/Python library for population genetics.

This library offers *two* simulation packages for population genetics: one for
low-dimensional simulations (up to ~15 loci) and one for high-dimensional ones.

Each package is based on a big class that represents a population:

   - ``haploid_lowd`` for low-dimensional populations
   - ``haploid_highd`` for high-dimensional simulations

A simple example routine is the following::

    #####################################
    #   EXAMPLE SCRIPT                  #
    #####################################
    import numpy as np
    import matplotlib.pyplot as plt
    import FFPopSim as h

    c = h.haploid_lowd(4)
    c.set_allele_frequencies([0,0.3,0.6,0.9], N=1000)
    c.evolve(100)
    c.plot_diversity_histogram()
    plt.show()
    #####################################

which evolves a population with 4 loci for 100 generations starting from fixed
allele frequencies, under neutral conditions, and plots the diversity
histogram afterwards.

For more usage examples, please consult the ``tests`` and ``examples`` folders.

"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _FFPopSim
else:
    import _FFPopSim

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _FFPopSim.SWIG_PyInstanceMethod_New
_swig_new_static_method = _FFPopSim.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _FFPopSim.delete_SwigPyIterator
    value = _swig_new_instance_method(_FFPopSim.SwigPyIterator_value)
    incr = _swig_new_instance_method(_FFPopSim.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_FFPopSim.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_FFPopSim.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_FFPopSim.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_FFPopSim.SwigPyIterator_copy)
    next = _swig_new_instance_method(_FFPopSim.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_FFPopSim.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_FFPopSim.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_FFPopSim.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_FFPopSim.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_FFPopSim.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_FFPopSim.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_FFPopSim.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_FFPopSim.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_FFPopSim.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _FFPopSim:
_FFPopSim.SwigPyIterator_swigregister(SwigPyIterator)

class _intVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim._intVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim._intVector___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim._intVector___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim._intVector___len__)
    __getslice__ = _swig_new_instance_method(_FFPopSim._intVector___getslice__)
    __setslice__ = _swig_new_instance_method(_FFPopSim._intVector___setslice__)
    __delslice__ = _swig_new_instance_method(_FFPopSim._intVector___delslice__)
    __delitem__ = _swig_new_instance_method(_FFPopSim._intVector___delitem__)
    __getitem__ = _swig_new_instance_method(_FFPopSim._intVector___getitem__)
    __setitem__ = _swig_new_instance_method(_FFPopSim._intVector___setitem__)
    pop = _swig_new_instance_method(_FFPopSim._intVector_pop)
    append = _swig_new_instance_method(_FFPopSim._intVector_append)
    empty = _swig_new_instance_method(_FFPopSim._intVector_empty)
    size = _swig_new_instance_method(_FFPopSim._intVector_size)
    swap = _swig_new_instance_method(_FFPopSim._intVector_swap)
    begin = _swig_new_instance_method(_FFPopSim._intVector_begin)
    end = _swig_new_instance_method(_FFPopSim._intVector_end)
    rbegin = _swig_new_instance_method(_FFPopSim._intVector_rbegin)
    rend = _swig_new_instance_method(_FFPopSim._intVector_rend)
    clear = _swig_new_instance_method(_FFPopSim._intVector_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim._intVector_get_allocator)
    pop_back = _swig_new_instance_method(_FFPopSim._intVector_pop_back)
    erase = _swig_new_instance_method(_FFPopSim._intVector_erase)

    def __init__(self, *args):
        _FFPopSim._intVector_swiginit(self, _FFPopSim.new__intVector(*args))
    push_back = _swig_new_instance_method(_FFPopSim._intVector_push_back)
    front = _swig_new_instance_method(_FFPopSim._intVector_front)
    back = _swig_new_instance_method(_FFPopSim._intVector_back)
    assign = _swig_new_instance_method(_FFPopSim._intVector_assign)
    resize = _swig_new_instance_method(_FFPopSim._intVector_resize)
    insert = _swig_new_instance_method(_FFPopSim._intVector_insert)
    reserve = _swig_new_instance_method(_FFPopSim._intVector_reserve)
    capacity = _swig_new_instance_method(_FFPopSim._intVector_capacity)
    __swig_destroy__ = _FFPopSim.delete__intVector

# Register _intVector in _FFPopSim:
_FFPopSim._intVector_swigregister(_intVector)

class vector_tree_step(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim.vector_tree_step_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___len__)
    __getslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___getslice__)
    __setslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___setslice__)
    __delslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___delslice__)
    __delitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___delitem__)
    __getitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___getitem__)
    __setitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_step___setitem__)
    pop = _swig_new_instance_method(_FFPopSim.vector_tree_step_pop)
    append = _swig_new_instance_method(_FFPopSim.vector_tree_step_append)
    empty = _swig_new_instance_method(_FFPopSim.vector_tree_step_empty)
    size = _swig_new_instance_method(_FFPopSim.vector_tree_step_size)
    swap = _swig_new_instance_method(_FFPopSim.vector_tree_step_swap)
    begin = _swig_new_instance_method(_FFPopSim.vector_tree_step_begin)
    end = _swig_new_instance_method(_FFPopSim.vector_tree_step_end)
    rbegin = _swig_new_instance_method(_FFPopSim.vector_tree_step_rbegin)
    rend = _swig_new_instance_method(_FFPopSim.vector_tree_step_rend)
    clear = _swig_new_instance_method(_FFPopSim.vector_tree_step_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim.vector_tree_step_get_allocator)
    pop_back = _swig_new_instance_method(_FFPopSim.vector_tree_step_pop_back)
    erase = _swig_new_instance_method(_FFPopSim.vector_tree_step_erase)

    def __init__(self, *args):
        _FFPopSim.vector_tree_step_swiginit(self, _FFPopSim.new_vector_tree_step(*args))
    push_back = _swig_new_instance_method(_FFPopSim.vector_tree_step_push_back)
    front = _swig_new_instance_method(_FFPopSim.vector_tree_step_front)
    back = _swig_new_instance_method(_FFPopSim.vector_tree_step_back)
    assign = _swig_new_instance_method(_FFPopSim.vector_tree_step_assign)
    resize = _swig_new_instance_method(_FFPopSim.vector_tree_step_resize)
    insert = _swig_new_instance_method(_FFPopSim.vector_tree_step_insert)
    reserve = _swig_new_instance_method(_FFPopSim.vector_tree_step_reserve)
    capacity = _swig_new_instance_method(_FFPopSim.vector_tree_step_capacity)
    __swig_destroy__ = _FFPopSim.delete_vector_tree_step

# Register vector_tree_step in _FFPopSim:
_FFPopSim.vector_tree_step_swigregister(vector_tree_step)

class vector_tree_key(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim.vector_tree_key_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___len__)
    __getslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___getslice__)
    __setslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___setslice__)
    __delslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___delslice__)
    __delitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___delitem__)
    __getitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___getitem__)
    __setitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_key___setitem__)
    pop = _swig_new_instance_method(_FFPopSim.vector_tree_key_pop)
    append = _swig_new_instance_method(_FFPopSim.vector_tree_key_append)
    empty = _swig_new_instance_method(_FFPopSim.vector_tree_key_empty)
    size = _swig_new_instance_method(_FFPopSim.vector_tree_key_size)
    swap = _swig_new_instance_method(_FFPopSim.vector_tree_key_swap)
    begin = _swig_new_instance_method(_FFPopSim.vector_tree_key_begin)
    end = _swig_new_instance_method(_FFPopSim.vector_tree_key_end)
    rbegin = _swig_new_instance_method(_FFPopSim.vector_tree_key_rbegin)
    rend = _swig_new_instance_method(_FFPopSim.vector_tree_key_rend)
    clear = _swig_new_instance_method(_FFPopSim.vector_tree_key_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim.vector_tree_key_get_allocator)
    pop_back = _swig_new_instance_method(_FFPopSim.vector_tree_key_pop_back)
    erase = _swig_new_instance_method(_FFPopSim.vector_tree_key_erase)

    def __init__(self, *args):
        _FFPopSim.vector_tree_key_swiginit(self, _FFPopSim.new_vector_tree_key(*args))
    push_back = _swig_new_instance_method(_FFPopSim.vector_tree_key_push_back)
    front = _swig_new_instance_method(_FFPopSim.vector_tree_key_front)
    back = _swig_new_instance_method(_FFPopSim.vector_tree_key_back)
    assign = _swig_new_instance_method(_FFPopSim.vector_tree_key_assign)
    resize = _swig_new_instance_method(_FFPopSim.vector_tree_key_resize)
    insert = _swig_new_instance_method(_FFPopSim.vector_tree_key_insert)
    reserve = _swig_new_instance_method(_FFPopSim.vector_tree_key_reserve)
    capacity = _swig_new_instance_method(_FFPopSim.vector_tree_key_capacity)
    __swig_destroy__ = _FFPopSim.delete_vector_tree_key

# Register vector_tree_key in _FFPopSim:
_FFPopSim.vector_tree_key_swigregister(vector_tree_key)

class list_tree_key(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim.list_tree_key_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim.list_tree_key___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim.list_tree_key___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim.list_tree_key___len__)
    __getslice__ = _swig_new_instance_method(_FFPopSim.list_tree_key___getslice__)
    __setslice__ = _swig_new_instance_method(_FFPopSim.list_tree_key___setslice__)
    __delslice__ = _swig_new_instance_method(_FFPopSim.list_tree_key___delslice__)
    __delitem__ = _swig_new_instance_method(_FFPopSim.list_tree_key___delitem__)
    __getitem__ = _swig_new_instance_method(_FFPopSim.list_tree_key___getitem__)
    __setitem__ = _swig_new_instance_method(_FFPopSim.list_tree_key___setitem__)
    pop = _swig_new_instance_method(_FFPopSim.list_tree_key_pop)
    append = _swig_new_instance_method(_FFPopSim.list_tree_key_append)
    empty = _swig_new_instance_method(_FFPopSim.list_tree_key_empty)
    size = _swig_new_instance_method(_FFPopSim.list_tree_key_size)
    swap = _swig_new_instance_method(_FFPopSim.list_tree_key_swap)
    begin = _swig_new_instance_method(_FFPopSim.list_tree_key_begin)
    end = _swig_new_instance_method(_FFPopSim.list_tree_key_end)
    rbegin = _swig_new_instance_method(_FFPopSim.list_tree_key_rbegin)
    rend = _swig_new_instance_method(_FFPopSim.list_tree_key_rend)
    clear = _swig_new_instance_method(_FFPopSim.list_tree_key_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim.list_tree_key_get_allocator)
    pop_back = _swig_new_instance_method(_FFPopSim.list_tree_key_pop_back)
    erase = _swig_new_instance_method(_FFPopSim.list_tree_key_erase)

    def __init__(self, *args):
        _FFPopSim.list_tree_key_swiginit(self, _FFPopSim.new_list_tree_key(*args))
    push_back = _swig_new_instance_method(_FFPopSim.list_tree_key_push_back)
    front = _swig_new_instance_method(_FFPopSim.list_tree_key_front)
    back = _swig_new_instance_method(_FFPopSim.list_tree_key_back)
    assign = _swig_new_instance_method(_FFPopSim.list_tree_key_assign)
    resize = _swig_new_instance_method(_FFPopSim.list_tree_key_resize)
    insert = _swig_new_instance_method(_FFPopSim.list_tree_key_insert)
    pop_front = _swig_new_instance_method(_FFPopSim.list_tree_key_pop_front)
    push_front = _swig_new_instance_method(_FFPopSim.list_tree_key_push_front)
    reverse = _swig_new_instance_method(_FFPopSim.list_tree_key_reverse)
    __swig_destroy__ = _FFPopSim.delete_list_tree_key

# Register list_tree_key in _FFPopSim:
_FFPopSim.list_tree_key_swigregister(list_tree_key)

class map_key_edge(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim.map_key_edge_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim.map_key_edge___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim.map_key_edge___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim.map_key_edge___len__)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()
    __getitem__ = _swig_new_instance_method(_FFPopSim.map_key_edge___getitem__)
    __delitem__ = _swig_new_instance_method(_FFPopSim.map_key_edge___delitem__)
    has_key = _swig_new_instance_method(_FFPopSim.map_key_edge_has_key)
    keys = _swig_new_instance_method(_FFPopSim.map_key_edge_keys)
    values = _swig_new_instance_method(_FFPopSim.map_key_edge_values)
    items = _swig_new_instance_method(_FFPopSim.map_key_edge_items)
    __contains__ = _swig_new_instance_method(_FFPopSim.map_key_edge___contains__)
    key_iterator = _swig_new_instance_method(_FFPopSim.map_key_edge_key_iterator)
    value_iterator = _swig_new_instance_method(_FFPopSim.map_key_edge_value_iterator)
    __setitem__ = _swig_new_instance_method(_FFPopSim.map_key_edge___setitem__)
    asdict = _swig_new_instance_method(_FFPopSim.map_key_edge_asdict)

    def __init__(self, *args):
        _FFPopSim.map_key_edge_swiginit(self, _FFPopSim.new_map_key_edge(*args))
    empty = _swig_new_instance_method(_FFPopSim.map_key_edge_empty)
    size = _swig_new_instance_method(_FFPopSim.map_key_edge_size)
    swap = _swig_new_instance_method(_FFPopSim.map_key_edge_swap)
    begin = _swig_new_instance_method(_FFPopSim.map_key_edge_begin)
    end = _swig_new_instance_method(_FFPopSim.map_key_edge_end)
    rbegin = _swig_new_instance_method(_FFPopSim.map_key_edge_rbegin)
    rend = _swig_new_instance_method(_FFPopSim.map_key_edge_rend)
    clear = _swig_new_instance_method(_FFPopSim.map_key_edge_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim.map_key_edge_get_allocator)
    count = _swig_new_instance_method(_FFPopSim.map_key_edge_count)
    erase = _swig_new_instance_method(_FFPopSim.map_key_edge_erase)
    find = _swig_new_instance_method(_FFPopSim.map_key_edge_find)
    lower_bound = _swig_new_instance_method(_FFPopSim.map_key_edge_lower_bound)
    upper_bound = _swig_new_instance_method(_FFPopSim.map_key_edge_upper_bound)
    __swig_destroy__ = _FFPopSim.delete_map_key_edge

# Register map_key_edge in _FFPopSim:
_FFPopSim.map_key_edge_swigregister(map_key_edge)

class map_key_node(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim.map_key_node_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim.map_key_node___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim.map_key_node___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim.map_key_node___len__)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()
    __getitem__ = _swig_new_instance_method(_FFPopSim.map_key_node___getitem__)
    __delitem__ = _swig_new_instance_method(_FFPopSim.map_key_node___delitem__)
    has_key = _swig_new_instance_method(_FFPopSim.map_key_node_has_key)
    keys = _swig_new_instance_method(_FFPopSim.map_key_node_keys)
    values = _swig_new_instance_method(_FFPopSim.map_key_node_values)
    items = _swig_new_instance_method(_FFPopSim.map_key_node_items)
    __contains__ = _swig_new_instance_method(_FFPopSim.map_key_node___contains__)
    key_iterator = _swig_new_instance_method(_FFPopSim.map_key_node_key_iterator)
    value_iterator = _swig_new_instance_method(_FFPopSim.map_key_node_value_iterator)
    __setitem__ = _swig_new_instance_method(_FFPopSim.map_key_node___setitem__)
    asdict = _swig_new_instance_method(_FFPopSim.map_key_node_asdict)

    def __init__(self, *args):
        _FFPopSim.map_key_node_swiginit(self, _FFPopSim.new_map_key_node(*args))
    empty = _swig_new_instance_method(_FFPopSim.map_key_node_empty)
    size = _swig_new_instance_method(_FFPopSim.map_key_node_size)
    swap = _swig_new_instance_method(_FFPopSim.map_key_node_swap)
    begin = _swig_new_instance_method(_FFPopSim.map_key_node_begin)
    end = _swig_new_instance_method(_FFPopSim.map_key_node_end)
    rbegin = _swig_new_instance_method(_FFPopSim.map_key_node_rbegin)
    rend = _swig_new_instance_method(_FFPopSim.map_key_node_rend)
    clear = _swig_new_instance_method(_FFPopSim.map_key_node_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim.map_key_node_get_allocator)
    count = _swig_new_instance_method(_FFPopSim.map_key_node_count)
    erase = _swig_new_instance_method(_FFPopSim.map_key_node_erase)
    find = _swig_new_instance_method(_FFPopSim.map_key_node_find)
    lower_bound = _swig_new_instance_method(_FFPopSim.map_key_node_lower_bound)
    upper_bound = _swig_new_instance_method(_FFPopSim.map_key_node_upper_bound)
    __swig_destroy__ = _FFPopSim.delete_map_key_node

# Register map_key_node in _FFPopSim:
_FFPopSim.map_key_node_swigregister(map_key_node)

class vector_polymorphism(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim.vector_polymorphism_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___len__)
    __getslice__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___getslice__)
    __setslice__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___setslice__)
    __delslice__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___delslice__)
    __delitem__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___delitem__)
    __getitem__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___getitem__)
    __setitem__ = _swig_new_instance_method(_FFPopSim.vector_polymorphism___setitem__)
    pop = _swig_new_instance_method(_FFPopSim.vector_polymorphism_pop)
    append = _swig_new_instance_method(_FFPopSim.vector_polymorphism_append)
    empty = _swig_new_instance_method(_FFPopSim.vector_polymorphism_empty)
    size = _swig_new_instance_method(_FFPopSim.vector_polymorphism_size)
    swap = _swig_new_instance_method(_FFPopSim.vector_polymorphism_swap)
    begin = _swig_new_instance_method(_FFPopSim.vector_polymorphism_begin)
    end = _swig_new_instance_method(_FFPopSim.vector_polymorphism_end)
    rbegin = _swig_new_instance_method(_FFPopSim.vector_polymorphism_rbegin)
    rend = _swig_new_instance_method(_FFPopSim.vector_polymorphism_rend)
    clear = _swig_new_instance_method(_FFPopSim.vector_polymorphism_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim.vector_polymorphism_get_allocator)
    pop_back = _swig_new_instance_method(_FFPopSim.vector_polymorphism_pop_back)
    erase = _swig_new_instance_method(_FFPopSim.vector_polymorphism_erase)

    def __init__(self, *args):
        _FFPopSim.vector_polymorphism_swiginit(self, _FFPopSim.new_vector_polymorphism(*args))
    push_back = _swig_new_instance_method(_FFPopSim.vector_polymorphism_push_back)
    front = _swig_new_instance_method(_FFPopSim.vector_polymorphism_front)
    back = _swig_new_instance_method(_FFPopSim.vector_polymorphism_back)
    assign = _swig_new_instance_method(_FFPopSim.vector_polymorphism_assign)
    resize = _swig_new_instance_method(_FFPopSim.vector_polymorphism_resize)
    insert = _swig_new_instance_method(_FFPopSim.vector_polymorphism_insert)
    reserve = _swig_new_instance_method(_FFPopSim.vector_polymorphism_reserve)
    capacity = _swig_new_instance_method(_FFPopSim.vector_polymorphism_capacity)
    __swig_destroy__ = _FFPopSim.delete_vector_polymorphism

# Register vector_polymorphism in _FFPopSim:
_FFPopSim.vector_polymorphism_swigregister(vector_polymorphism)

class vector_tree_node(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_FFPopSim.vector_tree_node_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___nonzero__)
    __bool__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___bool__)
    __len__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___len__)
    __getslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___getslice__)
    __setslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___setslice__)
    __delslice__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___delslice__)
    __delitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___delitem__)
    __getitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___getitem__)
    __setitem__ = _swig_new_instance_method(_FFPopSim.vector_tree_node___setitem__)
    pop = _swig_new_instance_method(_FFPopSim.vector_tree_node_pop)
    append = _swig_new_instance_method(_FFPopSim.vector_tree_node_append)
    empty = _swig_new_instance_method(_FFPopSim.vector_tree_node_empty)
    size = _swig_new_instance_method(_FFPopSim.vector_tree_node_size)
    swap = _swig_new_instance_method(_FFPopSim.vector_tree_node_swap)
    begin = _swig_new_instance_method(_FFPopSim.vector_tree_node_begin)
    end = _swig_new_instance_method(_FFPopSim.vector_tree_node_end)
    rbegin = _swig_new_instance_method(_FFPopSim.vector_tree_node_rbegin)
    rend = _swig_new_instance_method(_FFPopSim.vector_tree_node_rend)
    clear = _swig_new_instance_method(_FFPopSim.vector_tree_node_clear)
    get_allocator = _swig_new_instance_method(_FFPopSim.vector_tree_node_get_allocator)
    pop_back = _swig_new_instance_method(_FFPopSim.vector_tree_node_pop_back)
    erase = _swig_new_instance_method(_FFPopSim.vector_tree_node_erase)

    def __init__(self, *args):
        _FFPopSim.vector_tree_node_swiginit(self, _FFPopSim.new_vector_tree_node(*args))
    push_back = _swig_new_instance_method(_FFPopSim.vector_tree_node_push_back)
    front = _swig_new_instance_method(_FFPopSim.vector_tree_node_front)
    back = _swig_new_instance_method(_FFPopSim.vector_tree_node_back)
    assign = _swig_new_instance_method(_FFPopSim.vector_tree_node_assign)
    resize = _swig_new_instance_method(_FFPopSim.vector_tree_node_resize)
    insert = _swig_new_instance_method(_FFPopSim.vector_tree_node_insert)
    reserve = _swig_new_instance_method(_FFPopSim.vector_tree_node_reserve)
    capacity = _swig_new_instance_method(_FFPopSim.vector_tree_node_capacity)
    __swig_destroy__ = _FFPopSim.delete_vector_tree_node

# Register vector_tree_node in _FFPopSim:
_FFPopSim.vector_tree_node_swigregister(vector_tree_node)


LICENSE = '''FFPopSim is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. FFPopSim is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with FFPopSim. If not, see <http://www.gnu.org/licenses/>.'''


import numpy as _np

FREE_RECOMBINATION = _FFPopSim.FREE_RECOMBINATION

CROSSOVERS = _FFPopSim.CROSSOVERS

SINGLE_CROSSOVER = _FFPopSim.SINGLE_CROSSOVER

class index_value_pair(object):
    r"""Pair of an index and a value"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    index = property(_FFPopSim.index_value_pair_index_get, _FFPopSim.index_value_pair_index_set, doc=r"""Index""")
    val = property(_FFPopSim.index_value_pair_val_get, _FFPopSim.index_value_pair_val_set, doc=r"""Value""")

    def __init__(self, *args, **kwargs):
        r"""Pair of an index and a value"""
        _FFPopSim.index_value_pair_swiginit(self, _FFPopSim.new_index_value_pair(*args, **kwargs))
    __str__ = _swig_new_instance_method(_FFPopSim.index_value_pair___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.index_value_pair___repr__)
    __swig_destroy__ = _FFPopSim.delete_index_value_pair

# Register index_value_pair in _FFPopSim:
_FFPopSim.index_value_pair_swigregister(index_value_pair)

class genotype_value_pair(object):
    r"""Pair of a genotype and a value"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    genotype = property(_FFPopSim.genotype_value_pair_genotype_get, _FFPopSim.genotype_value_pair_genotype_set, doc=r"""Genotype""")
    val = property(_FFPopSim.genotype_value_pair_val_get, _FFPopSim.genotype_value_pair_val_set, doc=r"""Value""")

    def __init__(self, *args, **kwargs):
        r"""Pair of a genotype and a value"""
        _FFPopSim.genotype_value_pair_swiginit(self, _FFPopSim.new_genotype_value_pair(*args, **kwargs))
    __str__ = _swig_new_instance_method(_FFPopSim.genotype_value_pair___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.genotype_value_pair___repr__)
    __swig_destroy__ = _FFPopSim.delete_genotype_value_pair

# Register genotype_value_pair in _FFPopSim:
_FFPopSim.genotype_value_pair_swigregister(genotype_value_pair)

class stat(object):
    r"""Mean and variance of a statistical distribution"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    mean = property(_FFPopSim.stat_mean_get, _FFPopSim.stat_mean_set, doc=r"""Mean""")
    variance = property(_FFPopSim.stat_variance_get, _FFPopSim.stat_variance_set, doc=r"""Variance""")

    def __init__(self, *args, **kwargs):
        r"""Mean and variance of a statistical distribution"""
        _FFPopSim.stat_swiginit(self, _FFPopSim.new_stat(*args, **kwargs))
    __str__ = _swig_new_instance_method(_FFPopSim.stat___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.stat___repr__)
    __swig_destroy__ = _FFPopSim.delete_stat

# Register stat in _FFPopSim:
_FFPopSim.stat_swigregister(stat)


def binarify(gt, L=0):
    '''Transform an integer into a binary sequence on the L hypercube.

    Parameters:
       - gt: integer representing a genotype
       - L: number of dimensions of the hypercube

    Returns:
       - genotype: bool vector representing the same genotype

    **Examples**:

    .. sourcecode:: ipython

       In [1]: binarify(3, 5)
       Out[1]: array([False, False, False,  True,  True], dtype=bool)

       In [2]: FFPopSim.binarify(0b11, 5)
       Out[2]: array([False, False, False,  True,  True], dtype=bool)
    '''
    if not L:
        L=1
        while gt > ((1<<L) - 1):
            L += 1
    return _np.array(list(map(lambda l: bool(gt&(1<<(L-l-1))),range(L))))


def integerify(b):
    '''Transform a binary sequence on the HC into an integer.

    Parameters:
       - b: bool vector representing a genotype

    Returns:
       - gt: integer representing the same genotype

    **Examples**:

    .. sourcecode:: ipython

       In [1]: integerify([False, True, True])
       Out[1]: 3
    '''
    L = len(b)
    a = [(1<<(L-l-1)) for l in range(L)]
    return _np.dot(b,a)

HC_MEMERR = _FFPopSim.HC_MEMERR

HC_BADARG = _FFPopSim.HC_BADARG

HC_VERBOSE = _FFPopSim.HC_VERBOSE

HC_FUNC = _FFPopSim.HC_FUNC

HC_COEFF = _FFPopSim.HC_COEFF

HC_FUNC_EQ_COEFF = _FFPopSim.HC_FUNC_EQ_COEFF

HG_VERBOSE = _FFPopSim.HG_VERBOSE

HG_LONGTIMEGEN = _FFPopSim.HG_LONGTIMEGEN

HG_CONTINUOUS = _FFPopSim.HG_CONTINUOUS

HG_NOTHING = _FFPopSim.HG_NOTHING

HG_EXTINCT = _FFPopSim.HG_EXTINCT

HG_BADARG = _FFPopSim.HG_BADARG

HG_MEMERR = _FFPopSim.HG_MEMERR

class haploid_lowd(object):
    r"""
    Class for low-dimensional population genetics (short genomes ~20 loci).

    The class offers a number of functions, but an example will explain the basic idea::

        #####################################
        #   EXAMPLE SCRIPT                  #
        #####################################
        import numpy as np
        import matplotlib.pyplot as plt
        import FFPopSim as h

        c = h.haploid_lowd(5)               # 5 loci

        # initialize with 300 individuals with genotype 00000,
        # and 700 with genotype 00010
        c.set_genotypes([0, 2], [300, 700])

        # set an additive fitness landscape with these coefficients
        c.set_fitness_additive([0.02,0.03,0.04,0.02, -0.03])
        # Note: we are in the -/+ basis, so
        #        F[10000] - F[00000] = 2 * 0.02
        # Hence the coefficients are half of the effect of mutation on fitness

        c.evolve(100)                       # evolve for 100 generations
        c.plot_diversity_histogram()
        plt.show()
        #####################################

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        r"""
        Construct a low-dimensional population with certain parameters.

        Parameters:
            - L : number of loci (at least 1)
            - rng_seed : seed for the random number generator

        """
        _FFPopSim.haploid_lowd_swiginit(self, _FFPopSim.new_haploid_lowd(*args, **kwargs))
    __swig_destroy__ = _FFPopSim.delete_haploid_lowd
    carrying_capacity = property(_FFPopSim.haploid_lowd_carrying_capacity_get, _FFPopSim.haploid_lowd_carrying_capacity_set, doc=r"""current carrying capacity of the environment""")
    outcrossing_rate = property(_FFPopSim.haploid_lowd_outcrossing_rate_get, _FFPopSim.haploid_lowd_outcrossing_rate_set, doc=r"""outcrossing rate (probability of sexual reproduction per generation)""")
    circular = property(_FFPopSim.haploid_lowd_circular_get, _FFPopSim.haploid_lowd_circular_set, doc=r"""is the genome circular?""")
    _get_mutation_rate = _swig_new_instance_method(_FFPopSim.haploid_lowd__get_mutation_rate)
    _get_recombination_model = _swig_new_instance_method(_FFPopSim.haploid_lowd__get_recombination_model)

    def get_recombination_rate(self, *args, **kwargs):
        r"""
        Get the recombination rate between the specified locus and the following one.

        """

        if len(args) and (args[0] >= self.L - 1):
            raise ValueError("Expecting a locus from 0 to L - 2.")


        return _FFPopSim.haploid_lowd_get_recombination_rate(self, *args, **kwargs)


    def set_allele_frequencies(self, *args, **kwargs):
        r"""
        Initialize the population in linkage equilibrium with specified allele frequencies.

        Parameters:
           - frequencies: an array of length L with all allele frequencies
           - N: set the population size and, if still unset, the carrying
             capacity to this value

        .. note:: the population size is only used for resampling and has therefore
                  no effect on the speed of the simulation.

        """

        if len(args) and (len(args[0]) != self.L):
            raise ValueError('The input array of allele frequencies has the wrong length.')


        val = _FFPopSim.haploid_lowd_set_allele_frequencies(self, *args, **kwargs)

        return None


        return val


    def set_wildtype(self, *args, **kwargs):
        r"""
        Initialize population of N individuals with the - allele at all loci (wildtype)

        Parameters:
           - N: the number of individuals

        .. note:: the carrying capacity is set to the same value if still unset.

        """
        val = _FFPopSim.haploid_lowd_set_wildtype(self, *args, **kwargs)

        return None


        return val

    _set_recombination_model = _swig_new_instance_method(_FFPopSim.haploid_lowd__set_recombination_model)
    _set_recombination_rates = _swig_new_instance_method(_FFPopSim.haploid_lowd__set_recombination_rates)

    def evolve(self, *args, **kwargs):
        r"""
        Evolve for some generations

        Parameters:
            - gen: number of generations to evolve the population, defaults to one

        """
        val = _FFPopSim.haploid_lowd_evolve(self, *args, **kwargs)

        return None


        return val


    def evolve_norec(self, *args, **kwargs):
        r"""
        Evolve for some generations without recombination

        Parameters:
            - gen: number of generations to evolve the population

        """
        val = _FFPopSim.haploid_lowd_evolve_norec(self, *args, **kwargs)

        return None


        return val


    def evolve_deterministic(self, *args, **kwargs):
        r"""
        Evolve for some generations deterministically (skips the resampling)

        Parameters:
            - gen: number of generations to evolve the population

        """
        val = _FFPopSim.haploid_lowd_evolve_deterministic(self, *args, **kwargs)

        return None


        return val


    def get_genotype_frequency(self, *args, **kwargs):
        r"""
        Get the frequency of a genotype

        Parameters:
            - genotype: genotype, whose the frequency is to be returned

        Returns:
            - the frequency of the genotype

        """

        if len(args) and (args[0] >= (1<<self.L)):
            raise ValueError("Expecting an individual from 0 to 2^L - 1.")


        return _FFPopSim.haploid_lowd_get_genotype_frequency(self, *args, **kwargs)


    def get_allele_frequency(self, *args, **kwargs):
        r"""
        Get the frequency of the + allele

        Parameters:
            - locus: locus, at which the frequency of the + allele is to be computed

        Returns:
            - the frequency of the + allele, :math:`\nu_i := \frac{1 + \left<s_i\right>}{2}`, where :math:`s_i \in \{-1, 1\}`.

        """

        if len(args) and (args[0] >= (self.L)):
            raise ValueError("Expecting a locus from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_allele_frequency(self, *args, **kwargs)


    def get_pair_frequency(self, *args, **kwargs):
        r"""
        Get the frequency of genotypes with the + allele at both loci.

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the joint frequency of the + alleles

        """

        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_pair_frequency(self, *args, **kwargs)


    def get_chi(self, *args, **kwargs):
        r"""
        Get chi of an allele in the -/+ basis

        Parameters:
            - locus: locus whose chi is to be computed

        Returns:
            - the chi of that allele, :math:`\chi_i := \left<s_i\right>`, where :math:`s_i \in \{-1, 1\}`.

        """

        if len(args) and (args[0] >= (self.L)):
            raise ValueError("Expecting a locus from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_chi(self, *args, **kwargs)


    def get_chi2(self, *args, **kwargs):
        r"""
        Get :math:`\chi_{ij}`

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`\chi_{ij} := \left<s_i s_j\right> - \chi_i \cdot \chi_j`.

        """

        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_chi2(self, *args, **kwargs)


    def get_LD(self, *args, **kwargs):
        r"""
        Get linkage disequilibrium

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the linkage disequilibiurm between them, i.e. :math:`D_{ij} := 1 / 4 \left[\left<s_i s_j\right> - \chi_i \cdot \chi_j\right]`.

        """

        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_LD(self, *args, **kwargs)


    def get_moment(self, *args, **kwargs):
        r"""
        Get moment of two alleles in the -/+ basis

        Parameters:
            - locus1: first locus
            - locus2: second locus

        Returns:
            - the second moment, i.e. :math:`\left<s_i s_j\right>`, where :math:`s_i, s_j \in \{-1, 1\}`.

        """

        if (len(args) >= 2) and ((args[0] >= (self.L)) or (args[1] >= (self.L))):
            raise ValueError("Expecting loci from 0 to L - 1.")


        return _FFPopSim.haploid_lowd_get_moment(self, *args, **kwargs)

    genotype_entropy = _swig_new_instance_method(_FFPopSim.haploid_lowd_genotype_entropy)
    allele_entropy = _swig_new_instance_method(_FFPopSim.haploid_lowd_allele_entropy)

    def get_fitness(self, *args, **kwargs):
        r"""
        Get fitness values of a genotype

        Parameters:
            - genotype: genotype whose fitness is to be calculated. This can either be an integer or in binary format, e.g. 5 = 0b101

        Returns:
            - the fitness of that genotype.

        """

        if len(args) and (args[0] >= (1<<self.L)):
            raise ValueError("Expecting an individual between 0 and 2^L - 1.")


        return _FFPopSim.haploid_lowd_get_fitness(self, *args, **kwargs)


    def get_fitness_coefficient(self, *args, **kwargs):
        r"""
        Get fitness coefficient of a combination (bitset) of loci

        Parameters:
            - loci_bitset: Bitset of loci interested by the coefficient (see below). This can either be an integer or in binary format, e.g. 5 = 0b101

        .. note:: Examples for loci_bitset:
           - 0: fitness baseline for the population
           - (1 << X): additive coefficient for locus X
           - (1 << X) + (1 << Y): epistatic (2-locus) coefficient between loci X and Y

        .. note:: Remember that FFPopSim uses 1/-1 based hypercubes.

        Returns:
            - the fitness coefficient of that combination of loci.

        """

        if len(args) and (args[0] >= (1<<self.L)):
            raise ValueError("Expecting an individual between 0 and 2^L - 1.")


        return _FFPopSim.haploid_lowd_get_fitness_coefficient(self, *args, **kwargs)

    get_fitness_statistics = _swig_new_instance_method(_FFPopSim.haploid_lowd_get_fitness_statistics)
    __str__ = _swig_new_instance_method(_FFPopSim.haploid_lowd___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.haploid_lowd___repr__)

    def copy(self, rng_seed=0):
        '''Copy population into new instance.

        Parameters:
           - rng_seed: random number to initialize the new population
        '''
        pop = haploid_lowd(self.L, rng_seed=rng_seed)

    # Mutation and recombination
        if self.recombination_model not in ['FREE_RECOMBINATION']:
            pop.set_recombination_rates(self.get_recombination_rates(), self.recombination_model)
        tmp = self.get_mutation_rates()
        if _np.isscalar(tmp) or tmp.ndim < 2:
            pop.set_mutation_rates(tmp)
        else:
            pop.set_mutation_rates(*tmp)
        pop.circular = self.circular
        pop.outcrossing_rate = self.outcrossing_rate

    # Fitness
        pop.set_fitness_function(range(1<<self.L), self.get_fitnesses())

    # Population parameters
        pop.carrying_capacity = self.carrying_capacity
        pop.set_genotypes(range(1<<self.L), self.get_genotype_frequencies() * self.N)

    # Evolution
        pop.generation = self.generation

        return pop

    L = property(_FFPopSim.haploid_lowd_L_get, doc=r"""Number of loci (read-only)""")
    number_of_loci = property(_FFPopSim.haploid_lowd_number_of_loci_get, doc=r"""Number of loci (read-only)""")
    N = property(_FFPopSim.haploid_lowd_N_get, doc=r"""Population size (read-only)""")
    population_size = property(_FFPopSim.haploid_lowd_population_size_get, doc=r"""Population size (read-only)""")
    generation = property(_FFPopSim.haploid_lowd_generation_get, _FFPopSim.haploid_lowd_generation_set, doc=r"""Current generation (read-only)""")

    recombination_model = property(_get_recombination_model, _set_recombination_model)


    def status(self):
        '''Print a status list of the population parameters'''
        parameters = (('number of loci', 'L'),
                      ('circular', 'circular'),
                      ('population size', 'N'),
                      ('carrying capacity', 'carrying_capacity'),
                      ('generation', 'generation'),
                      ('outcrossing rate', 'outcrossing_rate'),
                      ('recombination model', 'recombination_model'),
                     )
        lenmax = max(map(lambda x: len(x[0]), parameters))

        for (strin, name) in parameters:
            par = getattr(self, name)
    # Recombination model needs a conversion
    # (a very frequently used one, to be honest)
            if strin == 'recombination model':
                if par == 0:
                    par = 'FREE_RECOMBINATION'
                elif par == 1:
                    par = 'SINGLE_CROSSOVER'
                else:
                    par = 'CROSSOVERS'
            print(('{:<'+str(lenmax + 2)+'s}').format(strin)+'\t'+str(par))

    _set_genotypes = _swig_new_instance_method(_FFPopSim.haploid_lowd__set_genotypes)

    def set_genotypes(self, genotypes, counts):
        '''Initialize population with fixed counts for specific genotypes.

        Parameters:
           - genotypes: list of genotypes to set. Genotypes are specified as integers,
                        from 00...0 that is 0, up to 11...1 that is 2^L-1.
           - counts: list of counts for those genotypes

        .. note:: the population size and, if unset, the carrying capacity will be set as the sum of the counts.
        .. note:: you can use Python binary notation for the indices, e.g. 0b0110 is 6.
        '''
        genotypes = _np.asarray(genotypes, float)
        counts = _np.asarray(counts, float)
        if len(genotypes) != len(counts):
            raise ValueError('Indices and counts must have the same length')
        if self._set_genotypes(genotypes, counts):
            raise RuntimeError('Error in the C++ function.')


    def get_recombination_rates(self):
        '''Get recombination rates.

    Returns:
        - the rates between neighboring loci, a list of float of length L-1

    .. note:: if the recombination model if FREE_RECOMBINATION, an error is raised.
        '''
        if self.L < 2:
            raise ValueError('There is no recombination with less than 2 loci.')

        rm = self.recombination_model
        if rm == FREE_RECOMBINATION:
            raise ValueError(('The current recombination model is free recombination,'+
                              'hence recombination rates are not defined.'+
                              ' Could you possibly mean outcrossing rate?'))
        elif rm in [SINGLE_CROSSOVER, CROSSOVERS]:
            return _np.array([self.get_recombination_rate(i) for i in range(self.L - 1)])
        else:
            raise RuntimeError('Recombination model not found')


    def set_recombination_rates(self, rates, model=None):
        '''Set the recombination rate(s).

    Parameters:
        - rates: if a double, the recombination rate at between any two loci; if an array,
          the locus-specific recombination rates
        - model: the recombination model to use (CROSSOVERS or, for linear
          genomes, SINGLE_CROSSOVER)

    .. note:: if locus-specific rates are specified, the array must have length
              (L-1) for linear chromosomes and length L for circular ones. The
              i-th element is the crossover rate between the i-th site and the
              (i+1)-th site.

    .. note:: if the recombination model is not specified, the current model will be kept or,
              if the current model is FREE_RECOMBINATION, then CROSSOVERS will be set.
        '''

    # Default recombination model
        if model is None:
            if self.recombination_model != FREE_RECOMBINATION:
                model = self.recombination_model
            else:
                model = CROSSOVERS

    # Check whether the model makes sense
        if model == FREE_RECOMBINATION:
            raise ValueError("Cannot assign rates to free recombination!")
        if model not in (CROSSOVERS, SINGLE_CROSSOVER):
            raise ValueError("Model not recognized.")
        if (self.circular and (model == SINGLE_CROSSOVER)):
            raise ValueError("Single crossover not available for circular genomes.")

    # Check whether the chromosome is circular
        if self.circular:
            len_rates = self.L
        else:
            len_rates = self.L - 1

    # Check whether the input argument is a list or a scalar
        if _np.isscalar(rates):
            self._set_recombination_rates([rates] * len_rates, model)

        elif len(rates) != len_rates:
            raise ValueError("Expecting an array of length "+str(len_rates)+".")
        else:
            self._set_recombination_rates(rates, model)



    def get_mutation_rates(self, locus=None, direction=None):
        '''Get one or several mutation rates.

    Parameters:
        - locus: get only the mutation rate(s) of this locus
        - direction: get only the forward or backward mutation rate(s). This argument
                     is a Boolean, 0/False for forward rates, 1/True for backward rates.

    Returns:
        - the mutation rate(s) requested

    **Note**: if the mutation rates for all loci and/or directions are the same,
    this function will try to be smart and give you the answer you are looking for.
    In case of doubt, you will get a matrix (L x 2) with the full mutation rate
    landscape.
        '''

        if locus is not None:
            if not _np.isscalar(locus):
                raise TypeError('Please select a *single* locus or no locus at all.')
            if direction is not None:
                return self._get_mutation_rate(locus, direction)
            else:
                mrs = tuple([self._get_mutation_rate(locus, d) for d in [0,1]])
                if mrs[0] == mrs[1]:
                    return mrs[0]
                else:
                    return mrs
        else:
            if direction is not None:
                mrs = _np.array([self._get_mutation_rate(l, direction) for l in range(self.L)])
                if len(_np.unique(mrs)) == 1:
                    return mrs[0]
                else:
                    return mrs
            else:
                mrs = _np.array([[self._get_mutation_rate(l, d) for l in range(self.L)] for d in [0,1]])
                if len(_np.unique(mrs)) == 1:
                    return mrs[0,0]
                else:
                    return mrs

    _set_mutation_rates = _swig_new_instance_method(_FFPopSim.haploid_lowd__set_mutation_rates)

    def set_mutation_rates(self, rates, rates_back=None):
        '''Set the mutation rate(s).

    Parameters:
        - rates:if a double, the mutation rate at any locus in both directions
          or, if rates_back is not None, only in the forward direction

          if a vector, the mutation rate is specified for each locus, the same
          in both directions or, if rates_back is not None, only in the
          forward direction

        - rates_back: mutation rate in the backward direction (global or
          locus-specific)
        '''

        L = self.L
        if _np.isscalar(rates):
            if rates_back is None:
                ratesm = _np.repeat(rates, L * 2).reshape(2,L)
            else:
                ratesm = _np.vstack([_np.repeat(rates, L), _np.repeat(rates_back, L)])
        elif (_np.rank(rates) != 1) or ((rates_back is not None) and (_np.rank(rates_back) != 1)):
            raise ValueError('Please input one/two numbers or arrays.')
        else:
            if rates_back is None:
                ratesm = _np.vstack([rates, rates])
            else:
                ratesm = _np.vstack([rates, rates_back])

        if self._set_mutation_rates(ratesm):
            raise RuntimeError('Error in the C++ function.')


    def get_genotype_frequencies(self):
        '''Get the frequency of each genotype.'''
        return _np.array([self.get_genotype_frequency(l) for l in range(1<<self.L)])


    def get_allele_frequencies(self):
        '''Get the frequencies of all + alleles'''
        return _np.array([self.get_allele_frequency(l) for l in range(self.L)])


    def random_genomes(self, n_sample):
        '''Get random genomes according sampled from the population.

        Parameters:
            - n_sample: number of random genomes to sample

        Returns:
            - integers corresponding to random genomes in the population.
        '''
        counts = _np.random.multinomial(n_sample, self.get_genotype_frequencies())
        ind = counts.nonzero()[0]
        counts = counts[ind]
        sample = _np.concatenate([_np.repeat(ind[i], counts[i]) for i in range(len(ind))])
        _np.random.shuffle(sample)
        return sample


    def get_fitnesses(self, *args, **kwargs):
        r"""Get the fitness of all possible genotypes."""

        args = tuple([1<<self.L] + list(args))


        return _FFPopSim.haploid_lowd_get_fitnesses(self, *args, **kwargs)


    def get_fitness_coefficients(self, *args, **kwargs):
        r"""
        Get all fitness coefficients.

        The order of the coefficient is by bitset of interested loci:
        - the population baseline is at position 0
        - the additive term of locus X is at position (1 << X), i.e. 2^X
        - the 2-locus epistatic term between loci X and Y is at (1 << X) + (1 << Y), i.e. 2^X + 2^Y
        and so on.

        For instance, the following indices contain:
        0 aka 0b0: baseline for the population
        1 aka 0b1: additive coefficient for the first locus
        2 aka 0b10: additive coefficient for the second locus
        3 aka 0b11: epistatic coefficient bewteen locus one and two
        4 aka 0b100: additive coefficient for the third locus
        5 aka 0b101: epistatic coefficient between locus one and three
        6 aka 0b110: epistatic coefficient between locus two and three
        7 aka 0b111: epistatic coefficient among loci one, two, and three (3-locus term)
        and so on.

        """

        args = tuple([1<<self.L] + list(args))


        return _FFPopSim.haploid_lowd_get_fitness_coefficients(self, *args, **kwargs)


    def get_fitness_histogram(self, n_sample=1000, **kwargs):
        '''Get the histogram of the fitness of a sample from the population.

        Parameters:
            - n_sample: number of individual to sample at random from the population. defaults to 1000

        Returns:
           - h: numpy.histogram of fitness in the population
        '''

    # Random sample
        gt = self.random_genomes(n_sample)

    # Calculate fitness
        fit = _np.array([self.get_fitness(gt[i]) for i in range(n_sample)])

        return _np.histogram(fit, **kwargs)


    def plot_fitness_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the fitness of a sample from the population.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population. Defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms
        '''

        import matplotlib.pyplot as plt

    # Random sample
        gt = self.random_genomes(n_sample)

    # Calculate fitness
        fit = _np.array([self.get_fitness(gt[i]) for i in range(n_sample)])

    # Plot
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Fitness histogram')
            axis.set_xlabel('Fitness')
        axis.hist(fit, **kwargs)


    def get_divergence_statistics(self, n_sample=1000):
        '''Get the mean and variance of the divergence of a population sample -- same as mean and variance of allele frequencies.

        Parameters:
            - n_sample: number of individuals to sample at random from the population. defaults to 1000.

        Returns:
            - stat: structure with mean and variance of divergence in the population
        '''

        L = self.L

    # Random sample
        gt = self.random_genomes(n_sample)

    # Calculate divegence
        div = _np.array([binarify(gt[i], L).sum() for i in range(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_divergence_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the divergence of a population sample.

        Parameters:
            - bins: number of bins or list of bin edges (passed verbatim to numpy.histogram)
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms

        Returns:
           - h: numpy.histogram of divergence in the population

        *Note*: to get a normalized histogram, use the *density* keyword.
        '''

    # Random sample
        gt = self.random_genomes(n_sample)

    # Calculate divergence
        div = _np.array([binarify(gt[i], self.L).sum() for i in range(n_sample)], int)

        return _np.histogram(div, bins=bins, **kwargs)


    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the divergence of a population sample.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms
        '''
        import matplotlib.pyplot as plt
        L = self.L

    # Random sample
        gt = self.random_genomes(n_sample)

    # Calculate divegence
        div = _np.array([binarify(gt[i], L).sum() for i in range(n_sample)], int)

    # Plot
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Divergence histogram')
            axis.set_xlabel('Divergence')

        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)


    def get_diversity_statistics(self, n_sample=1000):
        '''Get the mean and variance of the diversity of a population sample

        Parameters:
            - n_sample: number of individual to sample at random from the population, defaults to 1000.

        Returns:
            - stat: structure with mean and variance of diversity in the population
        '''

    # Random sample
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

    # Calculate diversity
        div = _np.array([binarify(gt1[i] ^ gt2[i], self.L).sum() for i in range(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_diversity_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the diversity in a sample from the population.

        Parameters:
            - bins: number of bins or list of bin edges (passed verbatim to numpy.histogram)
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms

        Returns:
           - h: numpy.histogram of diversity in the population

        *Note*: to get a normalized histogram, use the *density* keyword.
        '''

    # Random sample
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

    # Calculate diversity
        div = _np.array([binarify(gt1[i] ^ gt2[i], self.L).sum() for i in range(n_sample)], int)

    # Calculate histogram
        return _np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the diversity of a population sample.

        Parameters:
            - axis: use an already existing axis for the plot
            - n_sample: number of individual to sample at random from the population, defaults to 1000.
            - kwargs: further optional keyword arguments to numpy.histograms
        '''
        import matplotlib.pyplot as plt

    # Random sample
        gt1 = self.random_genomes(n_sample)
        gt2 = self.random_genomes(n_sample)

    # Calculate diversity
        div = _np.array([binarify(gt1[i] ^ gt2[i], self.L).sum() for i in range(n_sample)], int)

    # Plot
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Diversity histogram')
            axis.set_xlabel('Diversity')

        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)

    _set_fitness_func = _swig_new_instance_method(_FFPopSim.haploid_lowd__set_fitness_func)
    _set_fitness_coeff = _swig_new_instance_method(_FFPopSim.haploid_lowd__set_fitness_coeff)

    def set_fitness_function(self, genotypes, values):
        '''Set the fitness landscape for individual genotypes.

        Parameters:
           - genotypes: genotype to which the fitness values will be assigned. Genotypes are specified as integers,
                        from 00...0 that is 0, up to 11...1 that is 2^L-1.
           - values: fitness values to assign

        .. note:: you can use Python binary notation for the genotypes, e.g. 0b0110 is 6.
        '''
        genotypes = _np.asarray(genotypes, float)
        values = _np.asarray(values, float)
        if len(genotypes) != len(values):
            raise ValueError('Indices and values must have the same length')
        if self._set_fitness_func(genotypes, values):
            raise RuntimeError('Error in the C++ function.')


    def set_fitness_coefficients(self, coefficients, values):
        '''Set the fitness landscape in Fourier space for individual Fourier coefficients.

        Parameters:
           - coefficients: Fourier coefficients to which the values will be assigned. They are specified
                           as integers, from 00...0 that is 0, up to 11...1 that is 2^L-1.
           - values: values to assign

        .. note:: you can use Python binary notation for the coefficients, e.g. 0b0110 is 6.
        '''
        coefficients = _np.asarray(coefficients, float)
        values = _np.asarray(values, float)
        if len(coefficients) != len(values):
            raise ValueError('Indices and values must have the same length')
        if self._set_fitness_coeff(coefficients, values):
            raise RuntimeError('Error in the C++ function.')


    set_fitness_additive = _swig_new_instance_method(_FFPopSim.haploid_lowd_set_fitness_additive)

# Register haploid_lowd in _FFPopSim:
_FFPopSim.haploid_lowd_swigregister(haploid_lowd)


def load_haploid_highd(filename, gen_loci=[], include_genealogy=False):
    '''Load a population from a compressed pickle file

    Parameters:
       - filename: the path of the pickle file
       - gen_loci: start tracking these loci in the population
       - include_genealogy: load the old genealogy if present
    '''

    try:
        import cPickle as pickle
    except:
        import pickle

# Try the compressed format first
    try:
        import bz2
        with bz2.BZ2File(filename, 'rb') as f:
            pop_dict = pickle.load(f)
# Fallback on uncompressed
    except:
        with open(filename, 'rb') as f:
            pop_dict = pickle.load(f)


    pop = haploid_highd(pop_dict['L'],
                        all_polymorphic=pop_dict['all_polymorphic'],
                        number_of_traits=len(pop_dict['traits_additive']))
    pop.carrying_capacity = pop_dict['N']
    if pop.all_polymorphic == False:
        pop.mutation_rate = pop_dict['mu']
    pop.crossover_rate = pop_dict['crossover_rate']
    pop.outcrossing_rate = pop_dict['outcrossing_rate']
    pop.circular = pop_dict['circular']

    pop.recombination_model = pop_dict['recombination_model']
    for i in range(pop.number_of_traits):
        pop.set_trait_additive(pop_dict['traits_additive'][i], i)
        for (value, loci) in pop_dict['traits_epistasis'][i]:
            pop.add_trait_coefficient(value, loci, i)

    pop.trait_weights=pop_dict['trait_weights']

# Load the genealogy and track new loci if wished
    if include_genealogy and 'trees' in pop_dict:
        old_loci = pop_dict['trees'].keys()
    else:
        old_loci = []
    all_loci = list(set(list(old_loci) + list(gen_loci)))

    if len(all_loci):
        pop.track_locus_genealogy(all_loci)

    pop.generation = pop_dict['generation']

# Initialize the population
# Note: if the tree is recovered from the past, we insert empty clones to
# keep the labels of the leaves
    if include_genealogy and 'trees' in pop_dict:
        import numpy as np
        _nonempty_clones = pop_dict['_nonempty_clones']
        _maxclone = _nonempty_clones.max()
        genotypes = np.zeros((_maxclone + 1, pop.L), bool)
        clone_sizes = np.zeros(_maxclone + 1, int)
        genotypes[_nonempty_clones] = pop_dict['genotypes']
        clone_sizes[_nonempty_clones] = pop_dict['clone_sizes']
        pop.set_genotypes_and_ancestral_state(genotypes,
                                              clone_sizes,
                                              pop_dict['ancestral'])
        for (locus, tree_s) in pop_dict['trees'].iteritems():
            tree = rooted_tree()
            tree.read_newick(tree_s)
            pop._set_tree_in_genealogy(locus, tree)

# Make nodes out of non-SWIG objects for newGenerations
        def deserialize_leaf(serial):
            leaf = tree_node()
            for key in ['clone_size', 'crossover', 'fitness', 'number_of_offspring']:
                setattr(leaf, key, serial[key])
            leaf.own_key = tree_key(*serial['own_key'])
            leaf.parent_node = tree_key(*serial['parent_node'])
            return leaf

        for i, locus in enumerate(old_loci):
            pop._set_newGeneration_in_genealogy(locus, map(deserialize_leaf, pop_dict['_newGenerations'][i]))


    else:
        pop.set_genotypes_and_ancestral_state(pop_dict['genotypes'],
                                              pop_dict['clone_sizes'],
                                              pop_dict['ancestral'])


    return pop

HCF_MEMERR = _FFPopSim.HCF_MEMERR

HCF_BADARG = _FFPopSim.HCF_BADARG

HCF_VERBOSE = _FFPopSim.HCF_VERBOSE

WORDLENGTH = _FFPopSim.WORDLENGTH

HP_VERBOSE = _FFPopSim.HP_VERBOSE

NO_GENOTYPE = _FFPopSim.NO_GENOTYPE

HP_MINAF = _FFPopSim.HP_MINAF

MAX_DELTAFITNESS = _FFPopSim.MAX_DELTAFITNESS

MAX_POPSIZE = _FFPopSim.MAX_POPSIZE

HP_NOTHING = _FFPopSim.HP_NOTHING

HP_RANDOM_SAMPLE_FRAC = _FFPopSim.HP_RANDOM_SAMPLE_FRAC

HP_VERY_NEGATIVE = _FFPopSim.HP_VERY_NEGATIVE

HP_BADARG = _FFPopSim.HP_BADARG

HP_MEMERR = _FFPopSim.HP_MEMERR

HP_EXPLOSIONWARN = _FFPopSim.HP_EXPLOSIONWARN

HP_EXTINCTERR = _FFPopSim.HP_EXTINCTERR

HP_NOBINSERR = _FFPopSim.HP_NOBINSERR

HP_WRONGBINSERR = _FFPopSim.HP_WRONGBINSERR

HP_RUNTIMEERR = _FFPopSim.HP_RUNTIMEERR

class clone(object):
    r"""Clone of isogenetic individuals"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    genotype = property(_FFPopSim.clone_genotype_get, _FFPopSim.clone_genotype_set, doc=r"""Genotype of the clone""")
    fitness = property(_FFPopSim.clone_fitness_get, _FFPopSim.clone_fitness_set, doc=r"""Fitness of the clone""")
    clone_size = property(_FFPopSim.clone_clone_size_get, _FFPopSim.clone_clone_size_set, doc=r"""Number of individuals of the clone""")

    def __init__(self, *args, **kwargs):
        r"""Clone of isogenetic individuals"""
        _FFPopSim.clone_swiginit(self, _FFPopSim.new_clone(*args, **kwargs))
    __eq__ = _swig_new_instance_method(_FFPopSim.clone___eq__)
    __ne__ = _swig_new_instance_method(_FFPopSim.clone___ne__)
    __lt__ = _swig_new_instance_method(_FFPopSim.clone___lt__)
    __gt__ = _swig_new_instance_method(_FFPopSim.clone___gt__)
    __str__ = _swig_new_instance_method(_FFPopSim.clone___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.clone___repr__)
    number_of_traits = property(_FFPopSim.clone_number_of_traits_get, doc=r"""Number of traits (read-only)""")
    _get_trait = _swig_new_instance_method(_FFPopSim.clone__get_trait)

    @property
    def trait(self):
        '''Traits vector of the clone'''
        return self._get_trait(self.number_of_traits)

    __swig_destroy__ = _FFPopSim.delete_clone

# Register clone in _FFPopSim:
_FFPopSim.clone_swigregister(clone)

RT_VERBOSE = _FFPopSim.RT_VERBOSE

RT_VERYLARGE = _FFPopSim.RT_VERYLARGE

RT_CHILDNOTFOUND = _FFPopSim.RT_CHILDNOTFOUND

RT_NODENOTFOUND = _FFPopSim.RT_NODENOTFOUND

RT_LOCUSNOTFOUND = _FFPopSim.RT_LOCUSNOTFOUND

RT_FITNESS_MISSING = _FFPopSim.RT_FITNESS_MISSING

RT_CROSSOVER_MISSING = _FFPopSim.RT_CROSSOVER_MISSING

RT_SEGMENT_MISSING = _FFPopSim.RT_SEGMENT_MISSING

RT_ERROR_PARSING = _FFPopSim.RT_ERROR_PARSING

class tree_key(object):
    r"""Key for a phylogenetic tree, with index and age."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    index = property(_FFPopSim.tree_key_index_get, _FFPopSim.tree_key_index_set, doc=r"""Index of the key""")
    age = property(_FFPopSim.tree_key_age_get, _FFPopSim.tree_key_age_set, doc=r"""Age [in generations]""")
    __eq__ = _swig_new_instance_method(_FFPopSim.tree_key___eq__)
    __ne__ = _swig_new_instance_method(_FFPopSim.tree_key___ne__)
    __lt__ = _swig_new_instance_method(_FFPopSim.tree_key___lt__)
    __gt__ = _swig_new_instance_method(_FFPopSim.tree_key___gt__)

    def __init__(self, *args, **kwargs):
        r"""
        Initialize new tree_key.

        Parameters:
           - index: index of the key
           - age: age of the key

        """
        _FFPopSim.tree_key_swiginit(self, _FFPopSim.new_tree_key(*args, **kwargs))
    __str__ = _swig_new_instance_method(_FFPopSim.tree_key___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.tree_key___repr__)
    __hash__ = _swig_new_instance_method(_FFPopSim.tree_key___hash__)
    __swig_destroy__ = _FFPopSim.delete_tree_key

# Register tree_key in _FFPopSim:
_FFPopSim.tree_key_swigregister(tree_key)

class tree_step(object):
    r"""Step in a phylogenetic tree search"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    pos = property(_FFPopSim.tree_step_pos_get, _FFPopSim.tree_step_pos_set, doc=r"""Position""")
    step = property(_FFPopSim.tree_step_step_get, _FFPopSim.tree_step_step_set, doc=r"""Step [in generations]""")
    __lt__ = _swig_new_instance_method(_FFPopSim.tree_step___lt__)
    __gt__ = _swig_new_instance_method(_FFPopSim.tree_step___gt__)
    __eq__ = _swig_new_instance_method(_FFPopSim.tree_step___eq__)

    def __init__(self, *args, **kwargs):
        r"""
        Initialize new step.

        Parameters:
           - pos: position
           - step: length of step

        """
        _FFPopSim.tree_step_swiginit(self, _FFPopSim.new_tree_step(*args, **kwargs))
    __str__ = _swig_new_instance_method(_FFPopSim.tree_step___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.tree_step___repr__)
    __hash__ = _swig_new_instance_method(_FFPopSim.tree_step___hash__)
    __swig_destroy__ = _FFPopSim.delete_tree_step

# Register tree_step in _FFPopSim:
_FFPopSim.tree_step_swigregister(tree_step)

class tree_node(object):
    r"""Node of a phylogenetic tree"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    parent_node = property(_FFPopSim.tree_node_parent_node_get, _FFPopSim.tree_node_parent_node_set, doc=r"""Parent tree key""")
    own_key = property(_FFPopSim.tree_node_own_key_get, _FFPopSim.tree_node_own_key_set, doc=r"""Own tree key""")
    _child_edges = property(_FFPopSim.tree_node__child_edges_get, _FFPopSim.tree_node__child_edges_set, doc=r"""_child_edges : list<(tree_key_t)>""")
    fitness = property(_FFPopSim.tree_node_fitness_get, _FFPopSim.tree_node_fitness_set, doc=r"""Fitness  of the clone represented by the node""")
    _weight_distribution = property(_FFPopSim.tree_node__weight_distribution_get, _FFPopSim.tree_node__weight_distribution_set, doc=r"""_weight_distribution : vector<(step_t)>""")
    number_of_offspring = property(_FFPopSim.tree_node_number_of_offspring_get, _FFPopSim.tree_node_number_of_offspring_set, doc=r"""Number of offspring""")
    clone_size = property(_FFPopSim.tree_node_clone_size_get, _FFPopSim.tree_node_clone_size_set, doc=r"""Size of the clone represented by the node""")
    sampled = property(_FFPopSim.tree_node_sampled_get, _FFPopSim.tree_node_sampled_set, doc=r"""sampled : int""")
    sequence = property(_FFPopSim.tree_node_sequence_get, _FFPopSim.tree_node_sequence_set, doc=r"""sequence : boost::dynamic_bitset<()>""")
    __str__ = _swig_new_instance_method(_FFPopSim.tree_node___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.tree_node___repr__)

    @property
    def child_edges(self):
        '''Child edges of the node'''
        return list(self._child_edges)


    @child_edges.setter
    def child_edges(self, es):
        self._child_edges = list_tree_key(es)

    _get_crossover_chunk = _swig_new_instance_method(_FFPopSim.tree_node__get_crossover_chunk)
    _set_crossover_chunk = _swig_new_instance_method(_FFPopSim.tree_node__set_crossover_chunk)

    @property
    def crossover(self):
        '''Crossover of node'''
        return [self._get_crossover_chunk(i) for i in range(2)]

    @crossover.setter
    def crossover(self, value):
        if len(value) != 2:
            raise ValueError('Crossover is a pair of integers.')
        [self._set_crossover_chunk(value[i], i) for i in range(2)]


    @property
    def weight_distribution(self):
        '''Distribution of weights of this node'''
        return list(self._weight_distribution)

    @weight_distribution.setter
    def weight_distribution(self, distr):
        self._weight_distribution = vector_tree_step(distr)


    def __init__(self, *args, **kwargs):
        r"""Node of a phylogenetic tree"""
        _FFPopSim.tree_node_swiginit(self, _FFPopSim.new_tree_node(*args, **kwargs))
    __swig_destroy__ = _FFPopSim.delete_tree_node

# Register tree_node in _FFPopSim:
_FFPopSim.tree_node_swigregister(tree_node)

class tree_edge(object):
    r"""Edge of a phylogenetic tree"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    parent_node = property(_FFPopSim.tree_edge_parent_node_get, _FFPopSim.tree_edge_parent_node_set, doc=r"""Parent tree key""")
    own_key = property(_FFPopSim.tree_edge_own_key_get, _FFPopSim.tree_edge_own_key_set, doc=r"""Own tree key""")
    length = property(_FFPopSim.tree_edge_length_get, _FFPopSim.tree_edge_length_set, doc=r"""Edge length [in generations]""")
    number_of_offspring = property(_FFPopSim.tree_edge_number_of_offspring_get, _FFPopSim.tree_edge_number_of_offspring_set, doc=r"""Number of offspring""")
    __str__ = _swig_new_instance_method(_FFPopSim.tree_edge___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.tree_edge___repr__)
    _get_segment_chunk = _swig_new_instance_method(_FFPopSim.tree_edge__get_segment_chunk)

    @property
    def segment(self):
        '''Segment of edge'''
        return [self._get_segment_chunk(i) for i in range(2)]


    def __init__(self, *args, **kwargs):
        r"""Edge of a phylogenetic tree"""
        _FFPopSim.tree_edge_swiginit(self, _FFPopSim.new_tree_edge(*args, **kwargs))
    __swig_destroy__ = _FFPopSim.delete_tree_edge

# Register tree_edge in _FFPopSim:
_FFPopSim.tree_edge_swigregister(tree_edge)

class polymorphism(object):
    r"""Polymorphism history"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    birth = property(_FFPopSim.polymorphism_birth_get, _FFPopSim.polymorphism_birth_set, doc=r"""Birth generation""")
    sweep_time = property(_FFPopSim.polymorphism_sweep_time_get, _FFPopSim.polymorphism_sweep_time_set, doc=r"""Sweep time [in generations]""")
    effect = property(_FFPopSim.polymorphism_effect_get, _FFPopSim.polymorphism_effect_set, doc=r"""Fitness effect of the mutation""")
    fitness = property(_FFPopSim.polymorphism_fitness_get, _FFPopSim.polymorphism_fitness_set, doc=r"""Relative fitness of the clone at birth""")
    fitness_variance = property(_FFPopSim.polymorphism_fitness_variance_get, _FFPopSim.polymorphism_fitness_variance_set, doc=r"""Fitness variance of the population at birth""")

    def __init__(self, *args, **kwargs):
        r"""Polymorphism history"""
        _FFPopSim.polymorphism_swiginit(self, _FFPopSim.new_polymorphism(*args, **kwargs))
    __str__ = _swig_new_instance_method(_FFPopSim.polymorphism___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.polymorphism___repr__)
    __swig_destroy__ = _FFPopSim.delete_polymorphism

# Register polymorphism in _FFPopSim:
_FFPopSim.polymorphism_swigregister(polymorphism)

class rooted_tree(object):
    r"""
    Rooted phylogenetic tree.

    This class is used to represent the phylogenetic tree of a single locus.
    It is possible to print the tree in Newick format, to get the subtree
    spanned by some of the leaves, and to look at the tree nodes and edges.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    _edges = property(_FFPopSim.rooted_tree__edges_get, _FFPopSim.rooted_tree__edges_set, doc=r"""_edges : map<(tree_key_t,edge_t)>""")
    _nodes = property(_FFPopSim.rooted_tree__nodes_get, _FFPopSim.rooted_tree__nodes_set, doc=r"""_nodes : map<(tree_key_t,node_t)>""")
    _leafs = property(_FFPopSim.rooted_tree__leafs_get, _FFPopSim.rooted_tree__leafs_set, doc=r"""_leafs : vector<(tree_key_t)>""")
    _sampled_leafs = property(_FFPopSim.rooted_tree__sampled_leafs_get, _FFPopSim.rooted_tree__sampled_leafs_set, doc=r"""_sampled_leafs : vector<(tree_key_t)>""")
    root = property(_FFPopSim.rooted_tree_root_get, _FFPopSim.rooted_tree_root_set, doc=r"""root : tree_key_t""")
    MRCA = property(_FFPopSim.rooted_tree_MRCA_get, _FFPopSim.rooted_tree_MRCA_set, doc=r"""MRCA : tree_key_t""")

    def __init__(self, *args, **kwargs):
        r"""
        Rooted phylogenetic tree.

        This class is used to represent the phylogenetic tree of a single locus.
        It is possible to print the tree in Newick format, to get the subtree
        spanned by some of the leaves, and to look at the tree nodes and edges.

        """
        _FFPopSim.rooted_tree_swiginit(self, _FFPopSim.new_rooted_tree(*args, **kwargs))
    __swig_destroy__ = _FFPopSim.delete_rooted_tree
    external_branch_length = _swig_new_instance_method(_FFPopSim.rooted_tree_external_branch_length)
    total_branch_length = _swig_new_instance_method(_FFPopSim.rooted_tree_total_branch_length)
    calc_weight_distribution = _swig_new_instance_method(_FFPopSim.rooted_tree_calc_weight_distribution)
    print_newick = _swig_new_instance_method(_FFPopSim.rooted_tree_print_newick)
    print_sequences = _swig_new_instance_method(_FFPopSim.rooted_tree_print_sequences)
    subtree_newick = _swig_new_instance_method(_FFPopSim.rooted_tree_subtree_newick)
    print_weight_distribution = _swig_new_instance_method(_FFPopSim.rooted_tree_print_weight_distribution)
    read_newick = _swig_new_instance_method(_FFPopSim.rooted_tree_read_newick)
    get_sampled_leafs = _swig_new_instance_method(_FFPopSim.rooted_tree_get_sampled_leafs)
    set_sampled_leafs = _swig_new_instance_method(_FFPopSim.rooted_tree_set_sampled_leafs)
    __str__ = _swig_new_instance_method(_FFPopSim.rooted_tree___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.rooted_tree___repr__)
    _ancestors_at_age = _swig_new_instance_method(_FFPopSim.rooted_tree__ancestors_at_age)

    def ancestors_at_age(self, age, subtree):
        '''Find nodes in subtree younger than a certain age

        Parameters:
           - age: critical age to check
           - subtree: subtree to look for nodes in

        Returns:
           - ancestors: the ancestors at that age
        '''
        return list(self._ancestors_at_age(age, subtree))

    create_subtree_from_keys = _swig_new_instance_method(_FFPopSim.rooted_tree_create_subtree_from_keys)

    @property
    def edges(self):
        '''Edges of the tree'''
        return dict(self._edges)


    @edges.setter
    def edges(self, es):
        self._edges = map_key_edge(es)


    @property
    def nodes(self):
        '''Nodes of the tree'''
        return dict(self._nodes)


    @nodes.setter
    def nodes(self, ns):
        self._nodes = map_key_node(ns)


    @property
    def leafs(self):
        '''Leaves of the tree'''
        return list(self._leafs)


    @leafs.setter
    def leafs(self, leaves):
        self._leafs = vector_tree_key(leaves)


    @property
    def sampled_leafs(self):
        return list(self._sampled_leafs)


    @leafs.setter
    def sampled_leafs(self, leaves):
        self._sampled_leafs = vector_tree_key(leaves)


    def to_Biopython_tree(self):
        '''Convert the tree into Biopython format

        Returns:
           - tree: Biopython.Phylo phylogenetic tree representation of self
        '''
        from io import StringIO
        from Bio import Phylo

        treedata = self.print_newick()
        handle = StringIO(treedata)
        tree = Phylo.read(handle, "newick")
        return tree


# Register rooted_tree in _FFPopSim:
_FFPopSim.rooted_tree_swigregister(rooted_tree)

class multi_locus_genealogy(object):
    r"""Genealogy for multiple loci"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        r"""Default constructor"""
        _FFPopSim.multi_locus_genealogy_swiginit(self, _FFPopSim.new_multi_locus_genealogy(*args, **kwargs))
    __swig_destroy__ = _FFPopSim.delete_multi_locus_genealogy
    track_locus = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy_track_locus)
    reset = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy_reset)
    reset_but_loci = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy_reset_but_loci)
    __str__ = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy___repr__)
    _get_number_of_loci = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy__get_number_of_loci)
    _get_loci = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy__get_loci)

    @property
    def loci(self):
        '''The loci that are being tracked'''
        return self._get_loci(self._get_number_of_loci())

    get_tree = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy_get_tree)
    _set_tree = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy__set_tree)
    _get_newGeneration = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy__get_newGeneration)
    _set_newGeneration = _swig_new_instance_method(_FFPopSim.multi_locus_genealogy__set_newGeneration)

# Register multi_locus_genealogy in _FFPopSim:
_FFPopSim.multi_locus_genealogy_swigregister(multi_locus_genealogy)

class haploid_highd(object):
    r"""
    Class for high-dimensional population genetics (genomes larger than ~20 loci).

    This class is the main object for simulating the evolution of populations with
    many loci (more than ~20). The class offers a number of functions, but an
    example will explain the basic idea::

       ######################################
       #  EXAMPLE SCRIPT FOR HAPLOID_HIGHD  #
       ######################################
       import numpy as np
       import matplotlib.pyplot as plt
       import FFPopSim as h
       c = h.haploid_highd(300)       # 300 loci
       pop.set_wildtype(1000)         # start with 1000 wildtype individuals
       pop.mutation_rate = 1e-4       # mutation rate per site per generation
       pop.outcrossing_rate = 1e-1    # probability of sexual reproduction per gen
       pop.crossover_rate = 1e-2      # probability of crossover per site per gen
       pop.evolve(100)                # evolve for 100 generations
       c.plot_divergence_histogram()
       plt.show()
       ######################################

    Populations can have a number of phenotypic traits that contribute to the fitness
    of each individual. The function that calculates fitness from the phenotype
    identifies fitness with the first trait only by default. The user is, however,
    free to subclass haploid_highd in C++ (as it is done in hivpopulation) and
    implement their own phenotype -> fitness function.

    In addition, the trait landscapes describe the genotype -> phenotype maps.
    These can be set directly from Python (since the genotypic space has a finite
    number of elements).

    **Note**: fitness is not a phenotypic trait directly, but rather a function of *all*
    phenotypic traits together.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        r"""
        Construct a high-dimensional population with certain parameters.

        Parameters:
           - L: number of loci
           - rng_seed: seed for the random generator. If zero (default) pick a random number
           - number_of_traits: number of phenotypic traits, defaults to one
           - all_polymorphic: option to use an infinite-sites model tracking ancestral alleles
                              (only available with a single phenotypic trait and zero mutation rate)

        """
        _FFPopSim.haploid_highd_swiginit(self, _FFPopSim.new_haploid_highd(*args, **kwargs))
    __swig_destroy__ = _FFPopSim.delete_haploid_highd
    carrying_capacity = property(_FFPopSim.haploid_highd_carrying_capacity_get, _FFPopSim.haploid_highd_carrying_capacity_set, doc=r"""current carrying capacity of the environment""")
    outcrossing_rate = property(_FFPopSim.haploid_highd_outcrossing_rate_get, _FFPopSim.haploid_highd_outcrossing_rate_set, doc=r"""outcrossing rate (probability of sexual reproduction per generation)""")
    crossover_rate = property(_FFPopSim.haploid_highd_crossover_rate_get, _FFPopSim.haploid_highd_crossover_rate_set, doc=r"""crossover rate (probability of crossover per site per generation)""")
    recombination_model = property(_FFPopSim.haploid_highd_recombination_model_get, _FFPopSim.haploid_highd_recombination_model_set, doc=r"""
    Model of recombination to use

    Available values:
       - FFPopSim.FREE_RECOMBINATION: free reassortment of all loci between parents
       - FFPopSim.CROSSOVERS: linear chromosome with crossover probability per locus

    """)
    circular = property(_FFPopSim.haploid_highd_circular_get, _FFPopSim.haploid_highd_circular_set, doc=r"""is the genome circular?""")
    growth_rate = property(_FFPopSim.haploid_highd_growth_rate_get, _FFPopSim.haploid_highd_growth_rate_set, doc=r"""
    Growth rate

    This value is used to determine how fast a population converges to the
    carrying capacity.

    This parameter must be set strictly larger than 1 (very slow growth) and not
    too big to avoid population explosion. The default is 2, which means that a
    freely expanding population (N << carrying capacity) approximately doubles in
    size every generation.

    Note that when the population is shrinking, in order to avoid extinction, the
    population decreases by ten times or so only. If you want a hard bottleneck,
    use the bottleneck function.

    """)
    all_polymorphic = property(_FFPopSim.haploid_highd_all_polymorphic_get, _FFPopSim.haploid_highd_all_polymorphic_set, doc=r"""All polymorphic?""")
    _get_mutation_rate = _swig_new_instance_method(_FFPopSim.haploid_highd__get_mutation_rate)
    _set_mutation_rate = _swig_new_instance_method(_FFPopSim.haploid_highd__set_mutation_rate)
    get_all_polymorphic = _swig_new_instance_method(_FFPopSim.haploid_highd_get_all_polymorphic)
    set_all_polymorphic = _swig_new_instance_method(_FFPopSim.haploid_highd_set_all_polymorphic)
    _get_polymorphisms = _swig_new_instance_method(_FFPopSim.haploid_highd__get_polymorphisms)
    _get_fixed_mutations = _swig_new_instance_method(_FFPopSim.haploid_highd__get_fixed_mutations)
    _get_number_of_mutations = _swig_new_instance_method(_FFPopSim.haploid_highd__get_number_of_mutations)

    def set_allele_frequencies(self, *args, **kwargs):
        r"""
        Initialize the population according to the given allele frequencies in linkage equilibrium.

        Parameters:
           - frequencies: an array of length L with all allele frequencies
           - N: set the population size and, if still unset, the carrying
             capacity to this value

        """

        if len(args) and (len(args[0]) != self.L):
            raise ValueError('Please input an L dimensional list of allele frequencies.')


        val = _FFPopSim.haploid_highd_set_allele_frequencies(self, *args, **kwargs)

        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val


    def set_wildtype(self, *args, **kwargs):
        r"""
        Initialize a population of wildtype individuals

        Parameters:
           - N: the number of individuals

        .. note:: the carrying capacity is set to the same value if still unset.

        """
        val = _FFPopSim.haploid_highd_set_wildtype(self, *args, **kwargs)

        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    track_locus_genealogy = _swig_new_instance_method(_FFPopSim.haploid_highd_track_locus_genealogy)

    def add_genotype(self, *args, **kwargs):
        r"""
        Add new individuals to the population with certain genotypes

        Parameters:
           - genotype: genotype to add to the population (Boolean list)
           - n: number of new individuals carrying that genotype

        """
        val = _FFPopSim.haploid_highd_add_genotype(self, *args, **kwargs)

        self._nonempty_clones = _np.array(self._get_nonempty_clones())


        return val

    add_trait_coefficient = _swig_new_instance_method(_FFPopSim.haploid_highd_add_trait_coefficient)
    clear_trait = _swig_new_instance_method(_FFPopSim.haploid_highd_clear_trait)
    clear_traits = _swig_new_instance_method(_FFPopSim.haploid_highd_clear_traits)
    set_random_trait_epistasis = _swig_new_instance_method(_FFPopSim.haploid_highd_set_random_trait_epistasis)
    add_fitness_coefficient = _swig_new_instance_method(_FFPopSim.haploid_highd_add_fitness_coefficient)
    clear_fitness = _swig_new_instance_method(_FFPopSim.haploid_highd_clear_fitness)
    set_random_epistasis = _swig_new_instance_method(_FFPopSim.haploid_highd_set_random_epistasis)

    def evolve(self, *args, **kwargs):
        r"""
        Evolve for some generations.

        Parameters:
           - gen: number of generations, defaults to one

        """
        val = _FFPopSim.haploid_highd_evolve(self, *args, **kwargs)

        self.calc_stat()
        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val


    def bottleneck(self, *args, **kwargs):
        r"""
        Make the population undergo a bottleneck

        Parameters:
           - size_of_bottleneck: the number of individuals at the bottleneck

        """
        val = _FFPopSim.haploid_highd_bottleneck(self, *args, **kwargs)

        self.calc_stat()
        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    flip_single_locus = _swig_new_instance_method(_FFPopSim.haploid_highd_flip_single_locus)
    calc_stat = _swig_new_instance_method(_FFPopSim.haploid_highd_calc_stat)

    def unique_clones(self, *args, **kwargs):
        r"""
        Recompress the clone structure

        During its evolution, identical clones might be generated by different routes at
        different times. This function merges any such duplicates into unique clones with
        the size equal to the sum of the sizes of the duplicates.

        """
        val = _FFPopSim.haploid_highd_unique_clones(self, *args, **kwargs)

        self._nonempty_clones = self._get_nonempty_clones()


        return val

    _get_nonempty_clones = _swig_new_instance_method(_FFPopSim.haploid_highd__get_nonempty_clones)

    def random_clone(self, *args, **kwargs):
        r"""
        Get a random clone

        Returns:
           - clone: index of the random clone

        """
        val = _FFPopSim.haploid_highd_random_clone(self, *args, **kwargs)

        val = (self._nonempty_clones == val).nonzero()[0][0]


        return val

    get_diversity_statistics = _swig_new_instance_method(_FFPopSim.haploid_highd_get_diversity_statistics)
    get_divergence_statistics = _swig_new_instance_method(_FFPopSim.haploid_highd_get_divergence_statistics)
    get_allele_frequency = _swig_new_instance_method(_FFPopSim.haploid_highd_get_allele_frequency)
    get_derived_allele_frequency = _swig_new_instance_method(_FFPopSim.haploid_highd_get_derived_allele_frequency)
    get_ancestral_state = _swig_new_instance_method(_FFPopSim.haploid_highd_get_ancestral_state)
    get_pair_frequency = _swig_new_instance_method(_FFPopSim.haploid_highd_get_pair_frequency)
    get_chi = _swig_new_instance_method(_FFPopSim.haploid_highd_get_chi)
    get_derived_chi = _swig_new_instance_method(_FFPopSim.haploid_highd_get_derived_chi)
    get_chi2 = _swig_new_instance_method(_FFPopSim.haploid_highd_get_chi2)
    get_LD = _swig_new_instance_method(_FFPopSim.haploid_highd_get_LD)
    get_moment = _swig_new_instance_method(_FFPopSim.haploid_highd_get_moment)
    get_trait_weight = _swig_new_instance_method(_FFPopSim.haploid_highd_get_trait_weight)

    def get_fitness(self, *args, **kwargs):
        r"""
        Get the fitness of an individual

        Parameters:
           - n: index of the clone whose fitness is to be computed

        Returns:
           - fitness: fitness value of that clone

        """

        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_fitness(self, *args, **kwargs)


    def get_clone_size(self, *args, **kwargs):
        r"""
        Get the size of a clone

        Parameters:
           - n: index of the clone

        Returns:
           - size: size of the selected clone

        """

        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_clone_size(self, *args, **kwargs)


    def get_trait(self, *args, **kwargs):
        r"""
        Get a trait of an individual

        Parameters:
           - n: index of the clone whose trait is to be computed
           - t: trait to be computed

        Returns:
           - trait: value of that trait for that clone

        """

        if (len(args) > 1) and (args[1] >= self.number_of_traits):
            raise ValueError("There are only "+str(self.number_of_traits)+" traits.")
        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_trait(self, *args, **kwargs)

    get_trait_epistasis = _swig_new_instance_method(_FFPopSim.haploid_highd_get_trait_epistasis)
    get_fitness_statistics = _swig_new_instance_method(_FFPopSim.haploid_highd_get_fitness_statistics)
    get_trait_statistics = _swig_new_instance_method(_FFPopSim.haploid_highd_get_trait_statistics)
    get_trait_covariance = _swig_new_instance_method(_FFPopSim.haploid_highd_get_trait_covariance)
    _update_traits = _swig_new_instance_method(_FFPopSim.haploid_highd__update_traits)
    _update_fitness = _swig_new_instance_method(_FFPopSim.haploid_highd__update_fitness)
    tree_sample = property(_FFPopSim.haploid_highd_tree_sample_get, _FFPopSim.haploid_highd_tree_sample_set, doc=r"""tree_sample : int""")
    __str__ = _swig_new_instance_method(_FFPopSim.haploid_highd___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.haploid_highd___repr__)

    @property
    def mutation_rate(self):
       '''mutation rate (per site per generation)'''
       return self._get_mutation_rate()

    @mutation_rate.setter
    def mutation_rate(self, m):
        if self.all_polymorphic and m != 0:
            raise ValueError("You cannot set all_polymorphic and a nonzero mutation rate.")
        else:
            self._set_mutation_rate(m)

    get_clone = _swig_new_instance_method(_FFPopSim.haploid_highd_get_clone)
    L = property(_FFPopSim.haploid_highd_L_get, doc=r"""Number of loci (read-only)""")
    number_of_loci = property(_FFPopSim.haploid_highd_number_of_loci_get, doc=r"""Number of loci (read-only)""")
    N = property(_FFPopSim.haploid_highd_N_get, doc=r"""Population size (read-only)""")
    population_size = property(_FFPopSim.haploid_highd_population_size_get, doc=r"""Population size (read-only)""")
    generation = property(_FFPopSim.haploid_highd_generation_get, _FFPopSim.haploid_highd_generation_set, doc=r"""Current generation (read-only)""")
    number_of_clones = property(_FFPopSim.haploid_highd_number_of_clones_get, doc=r"""Number of non-empty clones (read-only)""")
    number_of_traits = property(_FFPopSim.haploid_highd_number_of_traits_get, doc=r"""Number of traits (read-only)""")
    max_fitness = property(_FFPopSim.haploid_highd_max_fitness_get, doc=r"""Maximal fitness in the population (read-only)""")
    participation_ratio = property(_FFPopSim.haploid_highd_participation_ratio_get, doc=r"""Participation ratio (read-only)""")

    @property
    def polymorphisms(self):
        '''Polymorphisms from all_polymorphic (read-only)'''
        if not self.all_polymorphic:
            raise ValueError("all_polymorphic is not set.")
        return self._get_polymorphisms()


    @property
    def fixed_mutations(self):
        '''Fixed mutations from all_polymorphic (read-only)'''
        if not self.all_polymorphic:
            raise ValueError("all_polymorphic is not set.")
        return self._get_fixed_mutations()


    @property
    def number_of_mutations(self):
        '''Fixed mutations from all_polymorphic (read-only)'''
        if not self.all_polymorphic:
            raise ValueError("all_polymorphic is not set.")
        return self._get_number_of_mutations()


    def _set_trait_weights(self, *args, **kwargs):
        r"""_set_trait_weights(haploid_highd self, double * IN_ARRAY1)"""

        if len(args) and (len(args[0]) != self.number_of_traits):
            raise ValueError('The weights must be a sequence of length equal to the number of traits.')


        return _FFPopSim.haploid_highd__set_trait_weights(self, *args, **kwargs)


    def _get_trait_weights(self, *args, **kwargs):
        r"""
        weight of each trait on fitness

        .. note:: Fitness is updated automatically when the weights are changed.

        """

        args = tuple(list(args) + [self.number_of_traits])


        return _FFPopSim.haploid_highd__get_trait_weights(self, *args, **kwargs)


    trait_weights = property(_get_trait_weights, _set_trait_weights)


    def dump(self, filename, format='bz2', include_genealogy=False):
        '''Dump a population to binary file, for later use.

        Parameters:
           - filename: the path to the file where to store the information
           - format: one of 'bz2' or 'plain'. Choose the former if you want compression.
           - include_genealogy: if True, the multi_locus_genealogy is stored as well (if present).

        .. note:: The population can be reloaded using the function FFPopSim.load_haploid_highd.
        '''

        try:
            import cPickle as pickle
        except:
            import pickle

        pop_dict = {}
        pop_dict['genotypes'] = self.get_genotypes()
        pop_dict['N'] = self.carrying_capacity
        pop_dict['L'] = self.L
        pop_dict['mu'] = self.mutation_rate
        pop_dict['crossover_rate'] = self.crossover_rate
        pop_dict['outcrossing_rate'] = self.outcrossing_rate
        pop_dict['circular'] = self.circular
        pop_dict['generation'] = self.generation
        pop_dict['clone_sizes'] = self.get_clone_sizes()
        pop_dict['recombination_model'] = self.recombination_model
        pop_dict['traits_additive'] = [self.get_trait_additive(i) for i in range(self.number_of_traits)]
        pop_dict['traits_epistasis'] = [self.get_trait_epistasis(i) for i in range(self.number_of_traits)]
        pop_dict['all_polymorphic']  = self.all_polymorphic
        pop_dict['ancestral'] = self.get_ancestral_states()
        pop_dict['trait_weights'] = self.trait_weights

    # Genealogy
        if include_genealogy and len(self.genealogy.loci):
            pop_dict['trees'] = {locus: self.genealogy.get_tree(locus).print_newick() for locus in self.genealogy.loci}
            pop_dict['_nonempty_clones'] = self._nonempty_clones

    # Save newGenerations as a non-SWIG object
            def serialize_leaf(leaf):
                serial = {}
                for key in ['clone_size', 'crossover', 'fitness', 'number_of_offspring']:
                    serial[key] = getattr(leaf, key)
                serial['own_key'] = (leaf.own_key.index, leaf.own_key.age)
                serial['parent_node'] = (leaf.parent_node.index, leaf.parent_node.age)
                return serial

            newGenerations = []
            for locus in self.genealogy.loci:
                newGenerations.append(map(serialize_leaf, self.genealogy._get_newGeneration(locus)))
            pop_dict['_newGenerations'] = newGenerations


        with open(filename, 'wb') as f:
            dump = pickle.dumps(pop_dict, pickle.HIGHEST_PROTOCOL)

    # Try to compress if the user wishes so
            try:
                if format == 'bz2':
                    import bz2
                    dump = dump.encode('bz2')
    # Fallback on uncompressed
            except:
                import warnings
                warnings.warn('compression module ('+format+') not found. Defaulting to uncompressed file.')
                format = 'plain'

    # Dump to file
            f.write(dump)


    def copy(self, rng_seed=0):
        '''Copy population into new instance.

        Parameters:
           - rng_seed: random number to initialize the new population
        '''
        pop = haploid_highd(self.L, rng_seed=rng_seed, number_of_traits=self.number_of_traits)

    # Mutation and recombination
        pop.recombination_model =  self.recombination_model
        pop.outcrossing_rate = self.outcrossing_rate
        pop.crossover_rate = self.crossover_rate
        pop.mutation_rate = self.mutation_rate
        pop.circular = self.circular

    # Fitness
        for i in range(self.number_of_traits):
            pop.set_trait_additive(self.get_trait_additive(i), i)
            for coeff in self.get_trait_epistasis(i):
                pop.add_trait_coefficient(coeff[0], coeff[1], i)

    # Population parameters
        pop.carrying_capacity = self.carrying_capacity
        pop.set_genotypes(self.get_genotypes(), self.get_clone_sizes())

    # Evolution
        pop.generation = self.generation

        return pop


    def status(self):
        '''Print a status list of the population parameters'''
        parameters = (('number of loci', 'L'),
                      ('circular', 'circular'),
                      ('number of traits', 'number_of_traits'),
                      ('population size', 'N'),
                      ('carrying capacity', 'carrying_capacity'),
                      ('generation', 'generation'),
                      ('outcrossing rate', 'outcrossing_rate'),
                      ('crossover rate', 'crossover_rate'),
                      ('recombination model', 'recombination_model'),
                      ('mutation rate', 'mutation_rate'),
                      ('participation ratio', 'participation_ratio'),
                      ('number of non-empty clones', 'number_of_clones'),
                     )
        lenmax = max(map(lambda x: len(x[0]), parameters))

        for (strin, name) in parameters:
            par = getattr(self, name)
    # Recombination model needs a conversion
    # (a very frequently used one, to be honest)
            if strin == 'recombination model':
                if par == 0:
                    par = 'FREE_RECOMBINATION'
                else:
                    par = 'CROSSOVERS'
            print(('{:<'+str(lenmax + 2)+'s}').format(strin)+'\t'+str(par))


    def set_genotypes(self, *args, **kwargs):
        r"""
        Initialize population with fixed counts for specific genotypes.

        Parameters:
           - genotypes: list of genotypes to set. Genotypes are lists of alleles,
             e.g. [[0,0,1,0], [0,1,1,1]] for genotypes 0010 and 0111
           - counts: list of the number at which each of those genotypes it to be present

        .. note:: the population size and, if unset, the carrying capacity will be set
                  as the sum of the counts.

        **Example**: if you want to initialize 200 individuals with genotype 001 and
                     300 individuals with genotype 110, you can use
                     ``set_genotypes([[0,0,1], [1,1,0]], [200, 300])``

        """

        if len(args) and (len(args) >= 2):
            genotypes = args[0]
            counts = args[1]
            genotypes = _np.array(genotypes, float, copy=False, ndmin=2)
            counts = _np.asarray(counts, float)
            if len(genotypes) != len(counts):
                raise ValueError('Genotypes and counts must have the same length')
            args = tuple([genotypes.ravel(), counts] + list(args[2:]))


        val = _FFPopSim.haploid_highd_set_genotypes(self, *args, **kwargs)

        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val


    def set_genotypes_and_ancestral_state(self, *args, **kwargs):
        r"""
        Initialize population with fixed counts for specific genotypes.

        Parameters:
           - genotypes: list of genotypes to set. Genotypes are lists of alleles,
             e.g. [[0,0,1,0], [0,1,1,1]] for genotypes 0010 and 0111
           - counts: list of the number at which each of those genotypes it to be present
           - ancestral state of the sample, a vector of 0 and 1
        .. note:: the population size and, if unset, the carrying capacity will be set
                  as the sum of the counts.

        **Example**: if you want to initialize 200 individuals with genotype 001 and
                     300 individuals with genotype 110, you can use
                     ``set_genotypes([[0,0,1], [1,1,0]], [200, 300])``

        """

        if len(args) and (len(args) >= 3):
            genotypes = args[0]
            counts = args[1]
            anc_state = args[2]
            genotypes = _np.array(genotypes, float, copy=False, ndmin=2)
            counts = _np.asarray(counts, float)
            anc_state = _np.asarray(anc_state, float)
            if len(genotypes) != len(counts):
                raise ValueError('Genotypes and counts must have the same length')
            if (len(anc_state) != self.L):
                raise ValueError('Ancestral state vector must have length L')
            args = tuple([genotypes.ravel(), counts] + list(args[2:]))


        val = _FFPopSim.haploid_highd_set_genotypes_and_ancestral_state(self, *args, **kwargs)

        self._nonempty_clones = _np.array(self._get_nonempty_clones())
        return None


        return val

    _get_genealogy = _swig_new_instance_method(_FFPopSim.haploid_highd__get_genealogy)

    genealogy = property(_get_genealogy)


    def get_allele_frequencies(self, *args, **kwargs):
        r"""Get all allele frequencies"""

        args = tuple(list(args) + [self.L])


        return _FFPopSim.haploid_highd_get_allele_frequencies(self, *args, **kwargs)


    def get_derived_allele_frequencies(self, *args, **kwargs):
        r"""Get all derived allele frequencies"""

        args = tuple(list(args) + [self.L])


        return _FFPopSim.haploid_highd_get_derived_allele_frequencies(self, *args, **kwargs)


    def get_ancestral_states(self, *args, **kwargs):
        r"""Get ancestral state of all loci"""

        args = tuple(list(args) + [self.L])


        return _FFPopSim.haploid_highd_get_ancestral_states(self, *args, **kwargs)


    def get_trait_additive(self, *args, **kwargs):
        r"""
        Get an array with the additive coefficients of all loci of a trait.

        Parameters:
           - t: number of the trait

        Returns:
           - coefficients: array of additive coefficients for the selected trait

        """

        if (len(args) > 1) and (args[1] >= self.number_of_traits):
            raise ValueError("There are only "+str(self.number_of_traits)+" traits.")
        args = tuple([self.L] + list(args))


        return _FFPopSim.haploid_highd_get_trait_additive(self, *args, **kwargs)


    def set_trait_additive(self, *args, **kwargs):
        r"""
        Set the additive part of a trait

        Parameters:
           - coefficients: array of coefficients for the trait (of length L). All previous additive coefficents are erased
           - t: number of the trait to set

        """

        if (len(args) > 1) and (args[1] >= self.number_of_traits):
            raise ValueError("There are only "+str(self.number_of_traits)+" traits.")
        if len(args) and (len(args[0]) != self.L):
            raise ValueError("L coefficients expected.")


        return _FFPopSim.haploid_highd_set_trait_additive(self, *args, **kwargs)


    def set_fitness_additive(self, *args, **kwargs):
        r"""Shortcut for set_trait_additive when there is only one trait"""

        if len(args) and (len(args[0]) != self.L):
            raise ValueError("L coefficients expected.")


        return _FFPopSim.haploid_highd_set_fitness_additive(self, *args, **kwargs)


    def get_fitnesses(self):
        '''Get the fitness of all clones.'''
        f = _np.zeros(self.number_of_clones)
        for i in range(self.number_of_clones):
            f[i] = self.get_fitness(i)
        return f


    def get_traits(self):
        '''Get all traits from all clones'''
        t = _np.zeros((self.number_of_clones, self.number_of_traits))
        for i in range(self.number_of_clones):
            for j in range(self.number_of_traits):
                t[i, j] = self.get_trait(i, j)
        return t


    def get_clone_sizes(self):
        '''Get the size of all clones.'''
        s = _np.zeros(self.number_of_clones, int)
        for i in range(self.number_of_clones):
            s[i] = self.get_clone_size(i)
        return s


    def get_genotype(self, *args, **kwargs):
        r"""get_genotype(haploid_highd self, int n) -> boost::dynamic_bitset< >"""

        if len(args) and (args[0] >= self.number_of_clones):
            raise ValueError('The population has only '+str(self.number_of_clones)+' clones.')
        if len(args):
            args = list(args)
            args[0] = self._nonempty_clones[args[0]]
            args = tuple(args)


        return _FFPopSim.haploid_highd_get_genotype(self, *args, **kwargs)


    def get_genotypes(self):
        '''Get all genotypes of the population.

        Return:
           - genotypes: boolean 2D array with the genotypes

        .. note:: this function does not return the sizes of each clone.
        '''
        genotypes = _np.zeros((self.number_of_clones, self.number_of_loci), bool)
        for i in range(self.number_of_clones):
            genotypes[i] = self.get_genotype(i)
        return genotypes


    def distance_Hamming(self, clone_gt1, clone_gt2, chunks=None, every=1):
        '''Calculate the Hamming distance between two genotypes

        Parameters:
           - clone_gt1: index of the clone corresponding to the first genotype
           - clone_gt2: index of the clone corresponding to the second genotype
           - chunks: list of pairs delimiting the genetic areas to include
           - every: do the comparison only on certain sites

        **Example**: to calculate the distance between the first two clones
        limited to third codon positions between locus 90 and 200, use:
        ``distance_Hamming(0, 1, chunks=[92, 200], every=3)``.
        '''
        if _np.isscalar(clone_gt1):
            genotypes = self.get_genotypes((clone_gt1, clone_gt2))
            clone_gt1 = genotypes[0]
            clone_gt2 = genotypes[1]

        if chunks is not None:
            ind = _np.zeros(clones.shape[1], bool)
            for chunk in chunks:
                inde = _np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            clone_gt1 = clone_gt1[ind]
            clone_gt2 = clone_gt2[ind]
        return (clone_gt1 != clone_gt2).sum()


    def random_genomes(self, n):
        '''Get a sample of random genomes from the population

        Parameters:
           - n: number of random genomes to compute

        Returns:
           - gts: (n x L) bool matrix with the n genotypes
        '''

        L = self.number_of_loci
        genotypes = _np.zeros((n, L), bool)
        for i in range(genotypes.shape[0]):
            genotypes[i] = self.get_genotype(self.random_clone())
        return genotypes


    def random_clones(self, n):
        '''Get random clones

        Parameters:
           - n: number of random clones to return

        Returns:
           - clones: clone indices
        '''
        return _np.array([self.random_clone() for i in range(n)], int)


    def get_fitness_histogram(self, n_sample=1000, **kwargs):
        '''Calculate the fitness histogram of a population sample.

        Parameters:
           - n_sample: number of individuals to sample

        Returns:
           - h: numpy.histogram of fitness in the population
        '''

        fit = [self.get_fitness(self.random_clone()) for i in range(n_sample)]
        h = _np.histogram(fit, **kwargs)
        return h


    def plot_fitness_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot a distribution of fitness of a population sample.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist

        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        fit = [self.get_fitness(self.random_clone()) for i in range(n_sample)]

        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Fitness histogram')
            axis.set_xlabel('Fitness')
        return axis.hist(fit, **kwargs)


    def get_divergence_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
        '''Get the divergence histogram restricted to those chunks of the genome.

        Parameters:
           - bins: number or array of bins to be used in the histogram (see also numpy.histogram)
           - chunks: restrict analysis to some chunk in the genome. It must be an n x 2 matrix with
                     the initial and (final+1) positions of the chunks
           - every: restrict analysis to every X positions. For instance, if every third site is neutral,
                    this argument can be used to only look at those neutral sites
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to numpy.histogram

        Returns:
           - h: numpy.histogram of divergence in the population
        '''

    # Check chunks
        if chunks is not None:
            chunks = _np.asarray(chunks)
            if (_np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')

    # Get the random genotypes
        genotypes = self.random_genomes(n_sample)

    # Restrict to the chunks
        if chunks is not None:
            ind = _np.zeros(genotypes.shape[1], bool)
            for chunk in chunks:
                inde = _np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            genotypes = genotypes[:,ind]

    # Calculate divergence
        div = genotypes.sum(axis=1)

    # Calculate histogram
        return _np.histogram(div, bins=bins, **kwargs)


    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the divergence histogram of a population sample.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist

        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        genotypes = self.random_genomes(n_sample)
        div = genotypes.sum(axis=1)

        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Divergence histogram')
            axis.set_xlabel('Divergence')

        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        return axis.hist(div, **kwargs)


    def get_diversity_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
        '''Get the diversity histogram restricted to those chunks of the genome.

        Parameters:
           - bins: number or array of bins to be used in the histogram (see also numpy.histogram)
           - chunks: restrict analysis to some chunk in the genome. It must be an n x 2 matrix with
                     the initial and (final+1) positions of the chunks
           - every: restrict analysis to every X positions. For instance, if every third site is neutral,
                    this argument can be used to only look at those neutral sites
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to numpy.histogram

        Returns:
           - h: numpy.histogram of diversity in the population
        '''

    # Check chunks
        if chunks is not None:
            chunks = _np.asarray(chunks)
            if (_np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')

    # Get the random genotypes
        genotypes = self.random_genomes(2 * n_sample)

    # Restrict to the chunks
        if chunks is not None:
            ind = _np.zeros(genotypes.shape[1], bool)
            for chunk in chunks:
                inde = _np.arange(chunk[1] - chunk[0])
                inde = inde[(inde % every) == 0] + chunk[0]
                ind[inde] = True
            genotypes = genotypes[:,ind]

    # Calculate diversity
        genotypes1 = genotypes[:genotypes.shape[0] / 2]
        genotypes2 = genotypes[-genotypes1.shape[0]:]
        div = (genotypes1 != genotypes2).sum(axis=1)

    # Calculate histogram
        return _np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the diversity histogram of a population sample.

        Parameters:
           - axis: an axis to use. A new figure is created by default
           - n_sample: number of individuals to sample
           - kwargs: further optional keyword arguments to matplotlib.pyplot.hist

        Returns:
           - return value of axis.hist(...)
        '''

        import matplotlib.pyplot as plt
        genotypes1 = self.random_genomes(n_sample)
        genotypes2 = self.random_genomes(n_sample)
        div = (genotypes1 != genotypes2).sum(axis=1)

        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Diversity histogram')
            axis.set_xlabel('Diversity')

        if 'bins' not in kwargs:
            kwargs['bins'] = _np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        return axis.hist(div, **kwargs)

    _set_tree_in_genealogy = _swig_new_instance_method(_FFPopSim.haploid_highd__set_tree_in_genealogy)
    _set_newGeneration_in_genealogy = _swig_new_instance_method(_FFPopSim.haploid_highd__set_newGeneration_in_genealogy)

# Register haploid_highd in _FFPopSim:
_FFPopSim.haploid_highd_swigregister(haploid_highd)

HIVPOP_VERBOSE = _FFPopSim.HIVPOP_VERBOSE

HIVPOP_BADARG = _FFPopSim.HIVPOP_BADARG

NOTHING = _FFPopSim.NOTHING

HIVGENOME = _FFPopSim.HIVGENOME

GAG_START = _FFPopSim.GAG_START

GAG_END = _FFPopSim.GAG_END

POL_START = _FFPopSim.POL_START

POL_END = _FFPopSim.POL_END

ENV_START = _FFPopSim.ENV_START

ENV_END = _FFPopSim.ENV_END

NEF_START = _FFPopSim.NEF_START

NEF_END = _FFPopSim.NEF_END

VIF_START = _FFPopSim.VIF_START

VIF_END = _FFPopSim.VIF_END

VPR_START = _FFPopSim.VPR_START

VPR_END = _FFPopSim.VPR_END

VPU_START = _FFPopSim.VPU_START

VPU_END = _FFPopSim.VPU_END

REV1_START = _FFPopSim.REV1_START

REV1_END = _FFPopSim.REV1_END

REV2_START = _FFPopSim.REV2_START

REV2_END = _FFPopSim.REV2_END

TAT1_START = _FFPopSim.TAT1_START

TAT1_END = _FFPopSim.TAT1_END

TAT2_START = _FFPopSim.TAT2_START

TAT2_END = _FFPopSim.TAT2_END

class hivgene(object):
    r"""Structure for an HIV gene."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    start = property(_FFPopSim.hivgene_start_get, _FFPopSim.hivgene_start_set, doc=r"""Initial position of the gene""")
    end = property(_FFPopSim.hivgene_end_get, _FFPopSim.hivgene_end_set, doc=r"""Final position of the gene""")
    second_start = property(_FFPopSim.hivgene_second_start_get, _FFPopSim.hivgene_second_start_set, doc=r"""second_start : unsigned int""")
    second_end = property(_FFPopSim.hivgene_second_end_get, _FFPopSim.hivgene_second_end_set, doc=r"""second_end : unsigned int""")

    def __init__(self, *args, **kwargs):
        r"""Structure for an HIV gene."""
        _FFPopSim.hivgene_swiginit(self, _FFPopSim.new_hivgene(*args, **kwargs))
    __str__ = _swig_new_instance_method(_FFPopSim.hivgene___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.hivgene___repr__)
    __swig_destroy__ = _FFPopSim.delete_hivgene

# Register hivgene in _FFPopSim:
_FFPopSim.hivgene_swigregister(hivgene)

class hivpopulation(haploid_highd):
    r"""
    Class for HIV population genetics (genome size = 10000).

    This class is the main object for simulating the evolution of HIV.
    The class offers a number of functions, but an example will explain the basic
    idea::

       #####################################
       #   EXAMPLE SCRIPT                  #
       #####################################
       import numpy as np
       import matplotlib.pyplot as plt
       import FFPopSim as h

       c = h.hivpopulation(2000)        # Create a population of 2000 individuals
       c.evolve(100)                    # Evolve (neutrally) for 100 generations
       c.plot_divergence_histogram()
       plt.show()
       #####################################

    **This class is a subclass of haploid_high and offers most of its methods.**
    In addition to the haploid_highd class, this class offers functions for reading
    fitness and drug resistance landscapes from a text file, and to save genomes as
    plain text or in compressed NumPy format.

    Moreover, there are two phenotypic traits, replication and resistance. Their
    relative importance for viral fitness is set by the ``treatment`` attribute::

       f[trait] = trait[0] + treatment * trait[1]

    By default, ``treatment`` is set to zero, to simulate non-treated patients.

    The gene structure of HIV is modelled roughly, including only start/end positions
    for the exons, using HXB2 as a reference. Different genes do not get automatically
    different fitness landscapes.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        r"""
        Construct a HIV population with certain parameters.

        Parameters:

           - N     number of viral particles
           - rng_seed	seed for the random number generator. If this is 0, time(NULL)+getpid() is used.
           - mutation_rate	mutation rate in events / generation / site
           - coinfection_rate	probability of coinfection of the same cell by two viral particles in events / generation
           - crossover_rate	probability of template switching during coinfection in events / site

        .. note:: the genome length is 10000 (see HIVGENOME).

        """
        _FFPopSim.hivpopulation_swiginit(self, _FFPopSim.new_hivpopulation(*args, **kwargs))
    __swig_destroy__ = _FFPopSim.delete_hivpopulation
    gag = property(_FFPopSim.hivpopulation_gag_get, _FFPopSim.hivpopulation_gag_set, doc=r"""gag : hivgene""")
    pol = property(_FFPopSim.hivpopulation_pol_get, _FFPopSim.hivpopulation_pol_set, doc=r"""pol : hivgene""")
    env = property(_FFPopSim.hivpopulation_env_get, _FFPopSim.hivpopulation_env_set, doc=r"""env : hivgene""")
    nef = property(_FFPopSim.hivpopulation_nef_get, _FFPopSim.hivpopulation_nef_set, doc=r"""nef : hivgene""")
    vif = property(_FFPopSim.hivpopulation_vif_get, _FFPopSim.hivpopulation_vif_set, doc=r"""vif : hivgene""")
    vpu = property(_FFPopSim.hivpopulation_vpu_get, _FFPopSim.hivpopulation_vpu_set, doc=r"""vpu : hivgene""")
    vpr = property(_FFPopSim.hivpopulation_vpr_get, _FFPopSim.hivpopulation_vpr_set, doc=r"""vpr : hivgene""")
    tat = property(_FFPopSim.hivpopulation_tat_get, _FFPopSim.hivpopulation_tat_set, doc=r"""tat : hivgene""")
    rev = property(_FFPopSim.hivpopulation_rev_get, _FFPopSim.hivpopulation_rev_set, doc=r"""rev : hivgene""")
    read_replication_coefficients = _swig_new_instance_method(_FFPopSim.hivpopulation_read_replication_coefficients)
    read_resistance_coefficients = _swig_new_instance_method(_FFPopSim.hivpopulation_read_resistance_coefficients)
    write_genotypes = _swig_new_instance_method(_FFPopSim.hivpopulation_write_genotypes)
    __str__ = _swig_new_instance_method(_FFPopSim.hivpopulation___str__)
    __repr__ = _swig_new_instance_method(_FFPopSim.hivpopulation___repr__)

    def copy(self, rng_seed=0):
        '''Copy population into new instance.

        Parameters:
           - rng_seed: random number to initialize the new population
        '''
        pop = hivpopulation(self.N,
                            rng_seed=rng_seed,
                            mutation_rate=self.mutation_rate,
                            coinfection_rate=self.outcrossing_rate,
                            crossover_rate=self.crossover_rate)

    # Fitness
        for i in range(self.number_of_traits):
            pop.set_trait_additive(self.get_trait_additive(i), i)
            for coeff in self.get_trait_epistasis(i):
                pop.add_trait_coefficient(coeff[0], coeff[1], i)

    # Population parameters
        pop.carrying_capacity = self.carrying_capacity
        pop.set_genotypes(self.get_genotypes(), self.get_clone_sizes())

    # Evolution
        pop._set_generation(self.generation)

        return pop

    treatment = property(_FFPopSim.hivpopulation_treatment_get, _FFPopSim.hivpopulation_treatment_set, doc=r"""
    Treatment weight (between 0 and 1)

    .. note:: this variable controls how important is either of the two phenotypic
              traits, replication and resistance. Their contribution to fitness is
              always linear (in this implementation).

    """)

    def write_genotypes_compressed(self, filename, sample_size, gt_label='', start=0, length=0):
        '''Store random genotypes into a compressed file.

        Parameters:
           - filename: string with the name of the file to store the genotype into
           - sample_size: how many random genotypes to store
           - gt_label: common fasta label for the genotypes (e.g. "HIV-sim")
           - start: if only a portion of the genome is to be stored, start from this position
           - length: store a chunk from ``start`` to this length

        The genotypes can be read using numpy.load.
        '''

        import numpy as np
        L = self.number_of_loci
        if length <= 0:
            length = L - start
        d = {}
        for i in range(sample_size):
            rcl = self.random_clone()
            d['>'+str(i)+'_GT-'+gt_label+'_'+str(rcl)] = self.get_genotype(rcl)[start:start+length]
        np.savez_compressed(filename, **d)


    def set_trait_landscape(self,
                            traitnumber=0,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set HIV trait landscape according to some general parameters.

        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.

        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        import numpy as np

    # Clear trait
        self.clear_trait(traitnumber)

    # Handy
        L = self.L
        aL = np.arange(L)

    # Decide what mutation is of what kind
    # Note: the rest, between
    #
    # lethal_fraction + deleterious_fraction and (1 - adaptive_fraction),
    #
    # is neutral, i.e. EXACTLY 0. Fair assumption.
        onetwo_vector = (aL % 3) < 2
        random_numbers = np.random.random(L)
        adaptive_mutations = (random_numbers > (1 - adaptive_fraction)) & onetwo_vector
        lethal_mutations = (random_numbers < lethal_fraction) & onetwo_vector
        deleterious_mutations = ((random_numbers > lethal_fraction) & \
                                 (random_numbers < (lethal_fraction + deleterious_fraction)) & \
                                 (random_numbers < (1 - adaptive_fraction)) & \
                                 onetwo_vector)

    # Decide how strong mutations are
        single_locus_effects=np.zeros(L)
        single_locus_effects[np.where(deleterious_mutations)] = -np.random.exponential(effect_size_deleterious, deleterious_mutations.sum())
        single_locus_effects[np.where(adaptive_mutations)] = np.random.exponential(effect_size_adaptive, adaptive_mutations.sum())
        single_locus_effects[np.where(lethal_mutations)] = -effect_size_lethal

    # Mutations in env are treated separately
        env_position = (aL >= self.env.start) & (aL < self.env.end)
        env_mutations = (random_numbers > (1 - env_fraction)) & onetwo_vector & env_position
        single_locus_effects[np.where(env_mutations)] = np.random.exponential(effect_size_env, env_mutations.sum())

    # Call the C++ routines
        self.set_trait_additive(single_locus_effects, traitnumber)

    # Epistasis
        multi_locus_coefficients=[]
        def add_epitope(strength=0.2):
            '''Note: we are in the +-1 basis.'''
            loci = random.sample(range(9),2)
            loci.sort()
            depression = - 0.05
            f1 = depression*0.25
            f2 = depression*0.25
            f12 = depression*0.25 - strength*0.5
            return loci, f1,f2,f12

        def add_valley(depth=0.1, height=0.01):
            '''Note: we are in the +-1 basis.'''
            f1 = height*0.25
            f2 = height*0.25
            f12 = height*0.25 + depth*0.5
            return (f1,f2,f12)

    # Set fitness valleys
        for vi in range(number_valleys):
            pos = np.random.random_integers(L/3-100)
            d = int(np.random.exponential(10) + 1)
            valley_str = np.random.exponential(valley_strength)
            if number_valleys:
                print('valley:', pos*3, valley_str)
            (f1,f2,f12)=add_valley(valley_str)
            single_locus_effects[pos*3+1]+=f1
            single_locus_effects[(pos+d)*3+1]+=f2
            multi_locus_coefficients.append([[pos*3+1, (pos+d)*3+1], f12])

    # Set epitopes (bumps, i.e. f_DM < d_WT << f_SM)
        for ei in range(number_epitopes):
            pos = np.random.random_integers(L/3-10)
            epi_strength = np.random.exponential(epitope_strength)
            if number_epitopes:
                    print('epitope', pos*3, epi_strength)
            epi, f1,f2,f12=add_epitope(epi_strength)
            single_locus_effects[(pos+epi[0])*3+1]+=f1
            single_locus_effects[(pos+epi[1])*3+1]+=f2
            multi_locus_coefficients.append([[(pos+epi[0])*3+1, (pos+epi[1])*3+1], f12])

        for mlc in multi_locus_coefficients:
            self.add_trait_coefficient(mlc[1], np.asarray(mlc[0], int), traitnumber)
        self._update_traits()
        self._update_fitness()


    def get_replication_additive(self):
        '''The additive part of the replication lansdscape.

        Returns:
           - coefficients: array of additive replication coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''
        return self.get_trait_additive(0)


    def set_replication_additive(self, coefficients):
        '''Set the additive replication coefficients

        Parameters:
           - coefficients: array of additive replication coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''

        self.set_trait_additive(coefficients, 0)


    def get_resistance_additive(self):
        '''The additive part of the resistance lansdscape.

        Returns:
           - coefficients: array of additive drug resistance coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''
        return self.get_trait_additive(1)


    def set_resistance_additive(self, coefficients):
        '''Set the additive drug resistance coefficients

        Parameters:
           - coefficients: array of additive drug resistance coefficients

        .. warning:: the -/+ basis is used throughout the library.
                     If you are used to the 0/1 basis, keep in mind that
                     the interaction series-expansion is different.
        '''

        self.set_trait_additive(coefficients, 1)




    def set_replication_landscape(self,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set the phenotypic landscape for the replication capacity of HIV.

        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.

        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        self.set_trait_landscape(traitnumber=0,
                            lethal_fraction=lethal_fraction,
                            deleterious_fraction=deleterious_fraction,
                            adaptive_fraction=adaptive_fraction,
                            effect_size_lethal=effect_size_lethal,
                            effect_size_deleterious=effect_size_deleterious,
                            effect_size_adaptive=effect_size_adaptive,
                            env_fraction=env_fraction,
                            effect_size_env=effect_size_env,
                            number_epitopes=number_epitopes,
                            epitope_strength=epitope_strength,
                            number_valleys=number_valleys,
                            valley_strength=valley_strength)


    def set_resistance_landscape(self,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set the phenotypic landscape for the drug resistance of HIV.

        Parameters:
           - lethal_fraction: fraction of lethal sites
           - deleterious_fraction: fraction of deleterious sites
           - adaptive_fraction: fraction of beneficial sites
           - effect_size_lethal: effect of lethal changes
           - effect_size_deleterious: average effect of deleterious changes
           - effect_size_adaptive: average effect of beneficial changes

           - env_fraction: fraction of beneficial sites in env
           - effect_size_env: average effect of beneficial changes in env
           - number_epitopes: number of (epistatic) epitopes
           - epitope_strength: average height of an epitope escape mutation
           - number_valleys: number of (epistatic) valleys
           - valley_strength: average depth of a valley

        .. note:: the effects of deleterious and beneficial sites are exponentially
                  distributed, i.e. most of them will still be almost neutral.

        .. note:: fractions refer to first and second positions only. For instance,
                  by default, 80% of first and second positions outside env are
                  deleterious.

        .. note:: the third positions are always neutral (synonymous).
        '''

        self.set_trait_landscape(traitnumber=1,
                            lethal_fraction=lethal_fraction,
                            deleterious_fraction=deleterious_fraction,
                            adaptive_fraction=adaptive_fraction,
                            effect_size_lethal=effect_size_lethal,
                            effect_size_deleterious=effect_size_deleterious,
                            effect_size_adaptive=effect_size_adaptive,
                            env_fraction=env_fraction,
                            effect_size_env=effect_size_env,
                            number_epitopes=number_epitopes,
                            epitope_strength=epitope_strength,
                            number_valleys=number_valleys,
                            valley_strength=valley_strength)




# Register hivpopulation in _FFPopSim:
_FFPopSim.hivpopulation_swigregister(hivpopulation)



