# coding: utf-8

"""
    nativeSDK

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 0.1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from native_sdk_core.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_allowance(self, chain, token, address, **kwargs):  # noqa: E501
        """Get Allowance  # noqa: E501

        Check for the amount of allowance an address has for a specific ERC20 token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allowance(chain, token, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :param object token: Token address (required)
        :param object address: User wallet address (required)
        :return: float
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_allowance_with_http_info(chain, token, address, **kwargs)  # noqa: E501
        else:
            (data) = self.get_allowance_with_http_info(chain, token, address, **kwargs)  # noqa: E501
            return data

    def get_allowance_with_http_info(self, chain, token, address, **kwargs):  # noqa: E501
        """Get Allowance  # noqa: E501

        Check for the amount of allowance an address has for a specific ERC20 token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_allowance_with_http_info(chain, token, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :param object token: Token address (required)
        :param object address: User wallet address (required)
        :return: float
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chain', 'token', 'address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_allowance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'chain' is set
        if ('chain' not in params or
                params['chain'] is None):
            raise ValueError("Missing the required parameter `chain` when calling `get_allowance`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_allowance`")  # noqa: E501
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `get_allowance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'chain' in params:
            query_params.append(('chain', params['chain']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/allowance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='float',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_balance(self, chain, token, address, **kwargs):  # noqa: E501
        """Get Balance  # noqa: E501

        Get user's balance for a specific token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_balance(chain, token, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :param object token: Token address (required)
        :param object address: User wallet address (required)
        :return: float
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_balance_with_http_info(chain, token, address, **kwargs)  # noqa: E501
        else:
            (data) = self.get_balance_with_http_info(chain, token, address, **kwargs)  # noqa: E501
            return data

    def get_balance_with_http_info(self, chain, token, address, **kwargs):  # noqa: E501
        """Get Balance  # noqa: E501

        Get user's balance for a specific token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_balance_with_http_info(chain, token, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :param object token: Token address (required)
        :param object address: User wallet address (required)
        :return: float
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chain', 'token', 'address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_balance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'chain' is set
        if ('chain' not in params or
                params['chain'] is None):
            raise ValueError("Missing the required parameter `chain` when calling `get_balance`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_balance`")  # noqa: E501
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `get_balance`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'chain' in params:
            query_params.append(('chain', params['chain']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/balance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='float',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_depth_chart(self, pool_pricing_id, **kwargs):  # noqa: E501
        """Get Depth Chart  # noqa: E501

        Given a pricing model,  Get a list of bid and ask prices for the depth chart  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_depth_chart(pool_pricing_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object pool_pricing_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_depth_chart_with_http_info(pool_pricing_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_depth_chart_with_http_info(pool_pricing_id, **kwargs)  # noqa: E501
            return data

    def get_depth_chart_with_http_info(self, pool_pricing_id, **kwargs):  # noqa: E501
        """Get Depth Chart  # noqa: E501

        Given a pricing model,  Get a list of bid and ask prices for the depth chart  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_depth_chart_with_http_info(pool_pricing_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object pool_pricing_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pool_pricing_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_depth_chart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pool_pricing_id' is set
        if ('pool_pricing_id' not in params or
                params['pool_pricing_id'] is None):
            raise ValueError("Missing the required parameter `pool_pricing_id` when calling `get_depth_chart`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pool_pricing_id' in params:
            query_params.append(('pool_pricing_id', params['pool_pricing_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/depth-chart', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firm_quote(self, pair, chain, side, amount, address, **kwargs):  # noqa: E501
        """Get Firm Quote  # noqa: E501

        Get a firm quote for user with the signed call data which the user can sign to approve the swap transaction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firm_quote(pair, chain, side, amount, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object pair: Supported swap token pair (required)
        :param object chain: Type of chain such as bsc or eth (required)
        :param object side: Type of action such as buy or sell (required)
        :param object amount: Amount of token to be sold (required)
        :param object address: User wallet address (required)
        :return: FirmQuote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firm_quote_with_http_info(pair, chain, side, amount, address, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firm_quote_with_http_info(pair, chain, side, amount, address, **kwargs)  # noqa: E501
            return data

    def get_firm_quote_with_http_info(self, pair, chain, side, amount, address, **kwargs):  # noqa: E501
        """Get Firm Quote  # noqa: E501

        Get a firm quote for user with the signed call data which the user can sign to approve the swap transaction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firm_quote_with_http_info(pair, chain, side, amount, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object pair: Supported swap token pair (required)
        :param object chain: Type of chain such as bsc or eth (required)
        :param object side: Type of action such as buy or sell (required)
        :param object amount: Amount of token to be sold (required)
        :param object address: User wallet address (required)
        :return: FirmQuote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'chain', 'side', 'amount', 'address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firm_quote" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pair' is set
        if ('pair' not in params or
                params['pair'] is None):
            raise ValueError("Missing the required parameter `pair` when calling `get_firm_quote`")  # noqa: E501
        # verify the required parameter 'chain' is set
        if ('chain' not in params or
                params['chain'] is None):
            raise ValueError("Missing the required parameter `chain` when calling `get_firm_quote`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `get_firm_quote`")  # noqa: E501
        # verify the required parameter 'amount' is set
        if ('amount' not in params or
                params['amount'] is None):
            raise ValueError("Missing the required parameter `amount` when calling `get_firm_quote`")  # noqa: E501
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `get_firm_quote`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'chain' in params:
            query_params.append(('chain', params['chain']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'amount' in params:
            query_params.append(('amount', params['amount']))  # noqa: E501
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/firm-quote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FirmQuote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_indicative_quote(self, pair, chain, side, amount, address, **kwargs):  # noqa: E501
        """Get Indicative Quote  # noqa: E501

        Receives a token and token amount as inputs and returns an indicative quote for the user to get an estimate of the amount of tokens he is expected to get from the swap  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_indicative_quote(pair, chain, side, amount, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object pair: Supported swap token pair (required)
        :param object chain: Type of chain such as bsc or eth (required)
        :param object side: Type of action such as buy or sell (required)
        :param object amount: Amount of token to be sold (required)
        :param object address: User wallet address (required)
        :return: IndicativeQuote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_indicative_quote_with_http_info(pair, chain, side, amount, address, **kwargs)  # noqa: E501
        else:
            (data) = self.get_indicative_quote_with_http_info(pair, chain, side, amount, address, **kwargs)  # noqa: E501
            return data

    def get_indicative_quote_with_http_info(self, pair, chain, side, amount, address, **kwargs):  # noqa: E501
        """Get Indicative Quote  # noqa: E501

        Receives a token and token amount as inputs and returns an indicative quote for the user to get an estimate of the amount of tokens he is expected to get from the swap  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_indicative_quote_with_http_info(pair, chain, side, amount, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object pair: Supported swap token pair (required)
        :param object chain: Type of chain such as bsc or eth (required)
        :param object side: Type of action such as buy or sell (required)
        :param object amount: Amount of token to be sold (required)
        :param object address: User wallet address (required)
        :return: IndicativeQuote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pair', 'chain', 'side', 'amount', 'address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_indicative_quote" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pair' is set
        if ('pair' not in params or
                params['pair'] is None):
            raise ValueError("Missing the required parameter `pair` when calling `get_indicative_quote`")  # noqa: E501
        # verify the required parameter 'chain' is set
        if ('chain' not in params or
                params['chain'] is None):
            raise ValueError("Missing the required parameter `chain` when calling `get_indicative_quote`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `get_indicative_quote`")  # noqa: E501
        # verify the required parameter 'amount' is set
        if ('amount' not in params or
                params['amount'] is None):
            raise ValueError("Missing the required parameter `amount` when calling `get_indicative_quote`")  # noqa: E501
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `get_indicative_quote`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pair' in params:
            query_params.append(('pair', params['pair']))  # noqa: E501
        if 'chain' in params:
            query_params.append(('chain', params['chain']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'amount' in params:
            query_params.append(('amount', params['amount']))  # noqa: E501
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/indicative-quote', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IndicativeQuote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_instruments(self, chain, **kwargs):  # noqa: E501
        """Get Instruments  # noqa: E501

        Get list of instruments users are approved to swap  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instruments(chain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :return: list[Instrument]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_instruments_with_http_info(chain, **kwargs)  # noqa: E501
        else:
            (data) = self.get_instruments_with_http_info(chain, **kwargs)  # noqa: E501
            return data

    def get_instruments_with_http_info(self, chain, **kwargs):  # noqa: E501
        """Get Instruments  # noqa: E501

        Get list of instruments users are approved to swap  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_instruments_with_http_info(chain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :return: list[Instrument]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_instruments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'chain' is set
        if ('chain' not in params or
                params['chain'] is None):
            raise ValueError("Missing the required parameter `chain` when calling `get_instruments`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'chain' in params:
            query_params.append(('chain', params['chain']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/instruments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Instrument]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pools(self, chain, **kwargs):  # noqa: E501
        """Get Pools  # noqa: E501

        Get list of pools created by the user in a specific chain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pools(chain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pools_with_http_info(chain, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pools_with_http_info(chain, **kwargs)  # noqa: E501
            return data

    def get_pools_with_http_info(self, chain, **kwargs):  # noqa: E501
        """Get Pools  # noqa: E501

        Get list of pools created by the user in a specific chain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pools_with_http_info(chain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object chain: Type of chain such as bsc or eth (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pools" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'chain' is set
        if ('chain' not in params or
                params['chain'] is None):
            raise ValueError("Missing the required parameter `chain` when calling `get_pools`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'chain' in params:
            query_params.append(('chain', params['chain']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/pools', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role(self, address, **kwargs):  # noqa: E501
        """Get Role  # noqa: E501

        Get user role based on the user wallet adddress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object address: User wallet address (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.get_role_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def get_role_with_http_info(self, address, **kwargs):  # noqa: E501
        """Get Role  # noqa: E501

        Get user role based on the user wallet adddress  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_with_http_info(address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object address: User wallet address (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `get_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/role', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_selected_pool_pricing(self, body, address, **kwargs):  # noqa: E501
        """Update Selected Pool Pricing  # noqa: E501

        Update pool pricing model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_selected_pool_pricing(body, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SelectPoolPricing body: (required)
        :param object address: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_selected_pool_pricing_with_http_info(body, address, **kwargs)  # noqa: E501
        else:
            (data) = self.update_selected_pool_pricing_with_http_info(body, address, **kwargs)  # noqa: E501
            return data

    def update_selected_pool_pricing_with_http_info(self, body, address, **kwargs):  # noqa: E501
        """Update Selected Pool Pricing  # noqa: E501

        Update pool pricing model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_selected_pool_pricing_with_http_info(body, address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SelectPoolPricing body: (required)
        :param object address: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_selected_pool_pricing" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_selected_pool_pricing`")  # noqa: E501
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `update_selected_pool_pricing`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIKeyCookie', 'APIKeyHeader', 'APIKeyQuery']  # noqa: E501

        return self.api_client.call_api(
            '/pool-pricing', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
