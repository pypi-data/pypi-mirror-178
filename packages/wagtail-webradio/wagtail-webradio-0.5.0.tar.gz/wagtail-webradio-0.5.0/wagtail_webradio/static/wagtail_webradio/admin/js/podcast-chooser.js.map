{"version":3,"file":"podcast-chooser.js","sources":["../../../../static_src/admin/js/podcast-chooser.js"],"sourcesContent":["import $ from 'jquery';\n\nfunction createPodcastChooser(id) {\n  const $chooser = $('#' + id + '-chooser');\n  const $title = $chooser.find('.title');\n  const $input = $('#' + id);\n  const $editLink = $chooser.find('.edit-link');\n  const chooserBaseUrl = $chooser.data('chooserUrl');\n\n  /*\n  Construct initial state of the chooser from the rendered (static) HTML and\n  arguments passed to createPodcastChooser. State is either null (= no podcast\n  chosen) or a dict of id, title and edit_link.\n\n  The result returned from the podcast chooser modal (see\n  wagtail_webradio.views.chooser.podcast_chosen) is a superset of this, and can\n  therefore be passed directly to chooser.setState.\n  */\n  let state = null;\n  if ($input.val()) {\n    state = {\n      id: $input.val(),\n      edit_link: $editLink.attr('href'),\n      title: $title.text(),\n    };\n  }\n\n  /* Define public API functions for the chooser */\n  const chooser = {\n    getState: () => state,\n    getValue: () => state && state.id,\n    setState(newState) {\n      if (newState) {\n        $input.val(newState.id);\n        $title.text(newState.title);\n        $chooser.removeClass('blank');\n        $editLink.attr('href', newState.edit_link);\n      } else {\n        $input.val('');\n        $chooser.addClass('blank');\n      }\n\n      state = newState;\n    },\n    getTextLabel(opts) {\n      if (!state) return null;\n      const result = state.title;\n      if (opts && opts.maxLength && result.length > opts.maxLength) {\n        return result.substring(0, opts.maxLength - 1) + 'â€¦';\n      }\n\n      return result;\n    },\n    focus() {\n      $('.action-choose', $chooser).focus();\n    },\n    openChooserModal() {\n      /* global ModalWorkflow, PODCAST_CHOOSER_MODAL_ONLOAD_HANDLERS */\n      ModalWorkflow({\n        url: chooserBaseUrl,\n        onload: PODCAST_CHOOSER_MODAL_ONLOAD_HANDLERS,\n        responses: {\n          podcastChosen(result) {\n            chooser.setState(result);\n          },\n        },\n      });\n    },\n\n    clear() {\n      chooser.setState(null);\n    },\n  };\n\n  $('.action-choose', $chooser).on('click', () => {\n    chooser.openChooserModal();\n  });\n\n  $('.action-clear', $chooser).on('click', () => {\n    chooser.clear();\n  });\n\n  return chooser;\n}\n\nwindow.createPodcastChooser = createPodcastChooser;\n"],"names":["window","createPodcastChooser","id","$chooser","$","$title","find","$input","$editLink","chooserBaseUrl","data","state","val","edit_link","attr","title","text","chooser","getState","getValue","setState","newState","removeClass","addClass","getTextLabel","opts","result","maxLength","length","substring","focus","openChooserModal","ModalWorkflow","url","onload","PODCAST_CHOOSER_MODAL_ONLOAD_HANDLERS","responses","podcastChosen","clear","on"],"mappings":"6GAqFAA,OAAOC,qBAnFP,SAA8BC,OACtBC,EAAWC,UAAE,IAAMF,EAAK,YACxBG,EAASF,EAASG,KAAK,UACvBC,EAASH,UAAE,IAAMF,GACjBM,EAAYL,EAASG,KAAK,cAC1BG,EAAiBN,EAASO,KAAK,cAWjCC,EAAQ,KACRJ,EAAOK,QACTD,EAAQ,CACNT,GAAIK,EAAOK,MACXC,UAAWL,EAAUM,KAAK,QAC1BC,MAAOV,EAAOW,aAKZC,EAAU,CACdC,SAAU,kBAAMP,GAChBQ,SAAU,kBAAMR,GAASA,EAAMT,IAC/BkB,kBAASC,GACHA,GACFd,EAAOK,IAAIS,EAASnB,IACpBG,EAAOW,KAAKK,EAASN,OACrBZ,EAASmB,YAAY,SACrBd,EAAUM,KAAK,OAAQO,EAASR,aAEhCN,EAAOK,IAAI,IACXT,EAASoB,SAAS,UAGpBZ,EAAQU,GAEVG,sBAAaC,OACNd,EAAO,OAAO,SACbe,EAASf,EAAMI,aACjBU,GAAQA,EAAKE,WAAaD,EAAOE,OAASH,EAAKE,UAC1CD,EAAOG,UAAU,EAAGJ,EAAKE,UAAY,GAAK,IAG5CD,GAETI,iBACE1B,UAAE,iBAAkBD,GAAU2B,SAEhCC,4BAEEC,cAAc,CACZC,IAAKxB,EACLyB,OAAQC,sCACRC,UAAW,CACTC,uBAAcX,GACZT,EAAQG,SAASM,QAMzBY,iBACErB,EAAQG,SAAS,eAIrBhB,UAAE,iBAAkBD,GAAUoC,GAAG,SAAS,WACxCtB,EAAQc,sBAGV3B,UAAE,gBAAiBD,GAAUoC,GAAG,SAAS,WACvCtB,EAAQqB,WAGHrB"}