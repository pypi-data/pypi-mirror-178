# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['WeatherUnits',
 'WeatherUnits.airQuality',
 'WeatherUnits.base',
 'WeatherUnits.config',
 'WeatherUnits.defaults',
 'WeatherUnits.defaults.WeatherFlow',
 'WeatherUnits.derived',
 'WeatherUnits.digital',
 'WeatherUnits.errors',
 'WeatherUnits.length',
 'WeatherUnits.mass',
 'WeatherUnits.others',
 'WeatherUnits.pressure',
 'WeatherUnits.temperature',
 'WeatherUnits.time_']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'weatherunits',
    'version': '0.7.1',
    'description': 'Easy conversion for common units',
    'long_description': "# WeatherUnits️ 🌧\nEasily convert typical weather units from one unit to another with automatic localization.\n\n## Features\n🌈 Effortlessly define or extend your own units\n\n☀️ Change nearly every part of unit display from a config.ini file. No need for additional code.\n\n❄️ Localization can is as simple as adding .localize to a units variable or setting it to automatic\n\n## Requirements\n\n- Python 3.10\n\n## How to use\n\n**Note: The following documentation is currently out of date after some major changes**\n\n### Unit Conversion\n\nConversion is as easy as using the desired unit's name or aliases as either an attribute or subscript\n\n```python\nfrom WeatherUnits.temperature import Fahrenheit\n>>> value = Fahrenheit(32)\n>>> value\n'32º'\n>>> value.withUnit\n'32ºf'\n>>> value['c'].withUnit\n'0ºc'\n>>> value.celcius\n'0º'\n```\n\n## Using a Config file\n\n#### Loading a config file\n```python\nimport WeatherUnits as wu\nwu.config.read('config.ini')\n```\nA template config file can be found in [src/WeatherUnits/config](src/WeatherUnits/config/template.ini).  There are three sections in a valid config file\n1) LocalUnits: This is what defines what units you want to use for localization\n2) UnitDefaults: This section holds the default values that apply to every unit\n3) UnitProperties: Defines properties for individual units or unit systems as a whole\n\n### UnitDefaults\nThe basic rules are:\n\n1) Properties are specified without the leading '_'\n2) Units are specified with their lowercase names or types\n3) Empty values will be read as '' and denote being set\n4) Values without an '=' will be read as None and denote being unset\n\n#### Properties\n- **precision:**  The number of digits allowed to be displayed past the decimal but will not exceed max Example number:\n\n    |example|3.14159m|\n    |-------|--------|\n    |0|3m|\n    |1|3.1m|\n    |2|3.14m|\n    |3|3.141m|\n\n- **max:**  The total number of digits that can be displayed while still showing the decimal.  If shorten is True, numbers would be reduced by factors of 10³\n\n    |example|415.25mm|\n    |-----|-------|\n    |2|0.4k mm|\n    |3|415mm|\n    |4|415.3mm|\n    |5|415.25mm|\n\n- **unit:** Override built in unit string\n- **suffix:** Override built in suffix string._Only used for shortening numbers_\n- **decorator:** Override built in decorator._Only used for º with degrees_\n- **title:** Title to be used by other display programs\n- **exp:** Override exponent.  I can't imagine why this would be used\n- **showUnit:** Show unit True: 5km False: 5\n- **leadingZero:** Display zero before values less than 1 True: 0.1in False: .1in\n- **trailingZero:** Display zero after decimal point to full precision staying under max True: 1.0in False: 1in True: 4.00cm\n- **unitSpacer:** Determines if there is a space between measurements and their units True: 90º f False: 90ºf\n- **kSeparator:**\n\n    |value|example|\n    |----|------|\n    |True|1,000ft|\n    |False|1000ft|\n\n- **shorten:** Shortens values to fit within the max display amount\n\n    |value|example|\n    |----|------|\n    |True|1k s|\n    |False|1000s|\n\n- **slide:** Scale units for the appropriate values. _Not yet implemented_\n\n    |value|example|\n    |----|------|\n    |True|1km|\n    |False|1000m|\n\n- **cardinal:** Show degrees as cardinal direction. **_Shorten_** _decides full vs abbreviated name_\n\n    |value|example|\n    |----|------|\n    |True|180º|\n    |False|South|\n\n- **key:** Key to be used for other programs\n- **sizeHint:** Override generated size hint string. Useful for when you know the expected max string length.\n\n\n## Defining Your Own Unit\n\nThere are currently three types of unit, **Static**, **Scaling**, and **Derived**\n\n### Static Unit\nThe most simple to define. Temperature is an example of a static unit.\nSimilar units of the same are a subclass of the unit type. In the example below,\nFahrenheit, Celsius, and Kelvin are subclasses of Temperature. Convert to other\nsimilar units with a single private function sharing the name of the desired unit.\n\n```python\nfrom WeatherUnits.base import Measurement, NamedType\n\n@NamedType  # Unit types are defined with this decorator.\nclass Temperature(Measurement):  # For static unit types, the class inherits Measurement.\n\n    # Shared unit properties are defined here or in a provided config file.\n    _decorator = 'º'\n\n    # Properties for converting units are defined in the main parent class.\n    @property\n    def fahrenheit(self):\n        # Unless all the subunits are defined in the same file, importing the desired\n        # class locally is currently necessary.\n        return Fahrenheit(self._fahrenheit())\n\n    # Unit abbreviations are defined somewhere below the converting property.\n    f = fahrenheit\n\n    @property\n    def celsius(self):\n        return Celsius(self._celsius())\n    c = celsius\n\nclass Fahrenheit(Temperature):\n    # Individual unit strings are defined as protected class variables\n    # for each unit or within a config file.\n    _unit = 'f'\n\n    # This method is what is called to convert Fahrenheit to Celsius.\n    def _celsius(self):\n        # Since Measurement is a float subclass, math can be done on self.\n        return (self - 32) / 1.8\n\n    def _fahrenheit(self):\n        # Currently, a function needs to be defined for even converting to the\n        # same unit to prevent errors.\n        return self\n\nclass Celsius(Temperature):\n    _unit = 'c'\n\n    def _celsius(self):\n        return self\n\n    def _fahrenheit(self):\n        return (self * 1.8) + 32\n```\n\n### Scaling Unit\n\nScaling units have quite a bit going on.  A scaling unit can be reduced to a single unit through a multiplier, this is the base unit.\nMultiple unit systems can be defined within one scale.  It is also to split systems separate scales as long as there is a function within\neach system that converts from one base unit to the other.\n\n- **SystemVariant:** A class that denotes is not the unit is not within the regular scale\n- **Synonym:** Denotes that a unit is the same as an already defined but uses another name. Synonym classes inherit their identically valued class\n- **Dimension:** Decorator that assigns the decorated class to _unitSystem of all child classes\n- **BaseUnit:** Decorator to define the base unit for the system, this will be used for converting to the non-standard 'SystemVariant'\n- **Scale:** Uses the metaclass EnumMeta to define the scaling factors for a ScalingMeasurement class along with the multipliers for any SystemVariants\nand the base unit\n\nTo define a scaling measurement (one that has multiple units within the same unit system, think Centimeter, Meter, Kilometer)\nthe unit system class inherits ScalingMeasurement.  The main difference from Measurement is the _Scale class defined inside the\nmain parent class.  In the example below, two unit systems (US and SI) are defined in the same scale.  Most US units\nhave an SI basis, so this can be done fairly often.  However, it is sometimes necessary to split them for readability.\n\n#### Unified System\n\n```python\n\nfrom WeatherUnits.base import NamedType, Synonym, ScalingMeasurement\nfrom WeatherUnits.base import Scale, BaseUnit, SystemVariant, Dimension\n\n@NamedType\nclass Pressure(ScalingMeasurement):\n\n    # The scale for the unit system is defined with by a class named _Scale inheriting.\n    class _Scale(Scale):\n        # Every unit is named here starting with the smallest unit and assigned a\n        # scaling multiplier.  Scaling multipliers here must be an integer.\n        Pascal = 1\n        Decapascal = 10\n        Hectopascal = 10\n\n        # A base unit is also defined denoted by Base = class.__name__.\n        # Base value must be a string.\n        Base = 'Pascal'\n\n        # System variants are units that fall outside of the normal scale\n        # The multiplier value for variants must be a float and be relative\n        # to the base unit.  For example, 1 Bar is 1000 Pascals and\n        # 1 MillimeterOfMercury is 1/0.00750062 or 133.3 Pascals.\n        Bar = 1000.\n        Atmosphere = 101325.\n        PoundsPerSquareInch = 6894.757293168\n        MillimeterOfMercury = 1 / 0.00750062\n        InchOfMercury = 1 / 0.00029530\n\n    @property\n    def pascal(self):\n        return Pascal(self)\n\n    @property\n    def hectopascal(self):\n        return Hectopascal(self)\n\n@BaseUnit\nclass Pascal(Pressure):\n    _unit = 'Pa'\n\nclass Hectopascal(Pressure):\n    _unit = 'hPa'\n\nclass Atmosphere(Pascal, SystemVariant):\n    _unit = 'atm'\n\n@Synonym\nclass Millibar(Hectopascal):\n    _unit = 'mBar'\n    _max = 4\n```\n\n#### Split system\n\n```python\nfrom WeatherUnits.base import NamedType, ScalingMeasurement, Dimension, BaseUnit\n\n\n@NamedType\nclass Length(ScalingMeasurement):\n\n    @property\n    def meter(self):\n        return Meter(self)\n    m = meter\n\n    @property\n    def foot(self):\n        return Foot(self)\n    ft = foot\n\n\nclass ImperialLength(Length):\n\n    class _Scale(Scale):\n        Line = 1\n        Inch = 12\n        Foot = 12\n        Yard = 3\n        Mile = 1760\n        Base = 'Foot'\n\n    # Since the multipliers are defined in _Scale, changeScale() uses one\n    # parameter to change the scale within the same system.\n    def _foot(self):\n        return self.changeScale(self._Scale.Foot)\n\n    # This function is called to convert from ImperialLength to MetricLength.  Once its\n    # converted to MetricLength, changeScale() is called within the MetricLength class\n    # to get to the final unit.\n    def _meter(self):\n        return self._foot() * 0.3048\n\n\n@BaseUnit\nclass Foot(ImperialLength):\n    _unit = 'ft'\n\n\n@Dimension\nclass MetricLength(Length):\n\n    class _Scale(Scale):\n        Millimeter = 1\n        Centimeter = 10\n        Decimeter = 10\n        Meter = 10\n        Decameter = 10\n        Hectometer = 10\n        Kilometer = 10\n        Base = 'Meter'\n\n    def _meter(self):\n        return self.changeScale(self._Scale.Meter)\n\n    # As with the pervious class, this method is called to convert from MetricLength\n    # to ImperialLength.\n    def _foot(self):\n        return self._meter() * 3.280839895013123\n\n\n@BaseUnit\nclass Meter(MetricLength):\n    _unit = 'm'\n```\n\n\n### Derived Unit\nDerivedMeasurement is essentially a measurement with multiple units, eg, m/s [meters per second], mph [miles per hour].\nInitiation takes in two Measurements and is stored as the dividend of the two.  Both values are independently stored\nas protected variables.\n\n**Note:**\nThis type still needs quite a lot of work.  Currently, it only has fractional support, and only a single unit can be used for\nboth the numerator and denominator.  Eventually this will be expanded allowing for more complex unit derivatives.\nSupport for the following has not been added:\n - Multiplying two units together, for example a pascal second [Pa·s]\n - Negative exponent units like Hertz [s⁻¹]\n - Multiple units in either the numerator or denominator\n\n```python\nfrom WeatherUnits import Length, Time\nfrom WeatherUnits.base import DerivedMeasurement, NamedType, NamedSubType\n\n\n# Summary of the DerivedMeasurement class\nclass DerivedMeasurement(Measurement):\n    _numerator: Measurement\n    _denominator: Measurement\n\n    def __init__(self, numerator, denominator):\n        self._numerator = numerator\n        self._denominator = denominator\n        Measurement.__init__(self, numerator / denominator)\n\n\n@NamedType\nclass DistanceOverTime(DerivedMeasurement):\n    # Defining the unit types for the derived unit helps keep things clear\n    _numerator: Length\n    _denominator: Time\n\n    # Currently all variations that will be used have to be defined as properties\n    @property\n    def mih(self):\n        converted = DistanceOverTime(self._numerator.mi, self._denominator.hr)\n\n        # Without this override, the unit would be displayed as 'mi/hr'\n        converted._suffix = 'mph'\n        return converted\n\n    @property\n    def ms(self):\n        return DistanceOverTime(self._numerator.m, self._denominator.s)\n\n    @property\n    def kmh(self):\n        return DistanceOverTime(self._numerator.km, self._denominator.hr)\n\n    mph = mih\n\n\n@NamedType\nclass Precipitation(DistanceOverTime):\n    _numerator: Length\n    _denominator: Time\n\n    @property\n    def inh(self):\n        return Precipitation(self._numerator.inch, self._denominator.hr)\n\n    @property\n    def mmh(self):\n        return Precipitation(self._numerator.mm, self._denominator.hr)\n\n\n@NamedType\nclass PrecipitationRate(Precipitation):\n    pass\n\n\n@NamedSubType\nclass Daily(Precipitation):\n\n    def __init__(self, numerator: Length, denominator: int = 1, *args, **kwargs):\n        if isinstance(denominator, int):\n            denominator = Time.Day(denominator)\n        Precipitation.__init__(self, numerator, denominator, *args, **kwargs)\n\n```",
    'author': 'noblecloud',
    'author_email': 'git@noblecloud.io',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/noblecloud/WeatherUnits',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
